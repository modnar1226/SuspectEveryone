// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  account: (where?: AccountWhereInput) => Promise<boolean>;
  accountCustomField: (
    where?: AccountCustomFieldWhereInput
  ) => Promise<boolean>;
  accountCustomValue: (
    where?: AccountCustomValueWhereInput
  ) => Promise<boolean>;
  admin: (where?: AdminWhereInput) => Promise<boolean>;
  contact: (where?: ContactWhereInput) => Promise<boolean>;
  contactCustomField: (
    where?: ContactCustomFieldWhereInput
  ) => Promise<boolean>;
  contactCustomValue: (
    where?: ContactCustomValueWhereInput
  ) => Promise<boolean>;
  job: (where?: JobWhereInput) => Promise<boolean>;
  migration: (where?: MigrationWhereInput) => Promise<boolean>;
  org: (where?: OrgWhereInput) => Promise<boolean>;
  passwordReset: (where?: PasswordResetWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  account: (where: AccountWhereUniqueInput) => AccountNullablePromise;
  accounts: (args?: {
    where?: AccountWhereInput;
    orderBy?: AccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Account>;
  accountsConnection: (args?: {
    where?: AccountWhereInput;
    orderBy?: AccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AccountConnectionPromise;
  accountCustomField: (
    where: AccountCustomFieldWhereUniqueInput
  ) => AccountCustomFieldNullablePromise;
  accountCustomFields: (args?: {
    where?: AccountCustomFieldWhereInput;
    orderBy?: AccountCustomFieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AccountCustomField>;
  accountCustomFieldsConnection: (args?: {
    where?: AccountCustomFieldWhereInput;
    orderBy?: AccountCustomFieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AccountCustomFieldConnectionPromise;
  accountCustomValue: (
    where: AccountCustomValueWhereUniqueInput
  ) => AccountCustomValueNullablePromise;
  accountCustomValues: (args?: {
    where?: AccountCustomValueWhereInput;
    orderBy?: AccountCustomValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AccountCustomValue>;
  accountCustomValuesConnection: (args?: {
    where?: AccountCustomValueWhereInput;
    orderBy?: AccountCustomValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AccountCustomValueConnectionPromise;
  admin: (where: AdminWhereUniqueInput) => AdminNullablePromise;
  admins: (args?: {
    where?: AdminWhereInput;
    orderBy?: AdminOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Admin>;
  adminsConnection: (args?: {
    where?: AdminWhereInput;
    orderBy?: AdminOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AdminConnectionPromise;
  contact: (where: ContactWhereUniqueInput) => ContactNullablePromise;
  contacts: (args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Contact>;
  contactsConnection: (args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ContactConnectionPromise;
  contactCustomField: (
    where: ContactCustomFieldWhereUniqueInput
  ) => ContactCustomFieldNullablePromise;
  contactCustomFields: (args?: {
    where?: ContactCustomFieldWhereInput;
    orderBy?: ContactCustomFieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ContactCustomField>;
  contactCustomFieldsConnection: (args?: {
    where?: ContactCustomFieldWhereInput;
    orderBy?: ContactCustomFieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ContactCustomFieldConnectionPromise;
  contactCustomValue: (
    where: ContactCustomValueWhereUniqueInput
  ) => ContactCustomValueNullablePromise;
  contactCustomValues: (args?: {
    where?: ContactCustomValueWhereInput;
    orderBy?: ContactCustomValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ContactCustomValue>;
  contactCustomValuesConnection: (args?: {
    where?: ContactCustomValueWhereInput;
    orderBy?: ContactCustomValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ContactCustomValueConnectionPromise;
  job: (where: JobWhereUniqueInput) => JobNullablePromise;
  jobs: (args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Job>;
  jobsConnection: (args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => JobConnectionPromise;
  migration: (where: MigrationWhereUniqueInput) => MigrationNullablePromise;
  migrations: (args?: {
    where?: MigrationWhereInput;
    orderBy?: MigrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Migration>;
  migrationsConnection: (args?: {
    where?: MigrationWhereInput;
    orderBy?: MigrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MigrationConnectionPromise;
  org: (where: OrgWhereUniqueInput) => OrgNullablePromise;
  orgs: (args?: {
    where?: OrgWhereInput;
    orderBy?: OrgOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Org>;
  orgsConnection: (args?: {
    where?: OrgWhereInput;
    orderBy?: OrgOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrgConnectionPromise;
  passwordResets: (args?: {
    where?: PasswordResetWhereInput;
    orderBy?: PasswordResetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PasswordReset>;
  passwordResetsConnection: (args?: {
    where?: PasswordResetWhereInput;
    orderBy?: PasswordResetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PasswordResetConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAccount: (data: AccountCreateInput) => AccountPromise;
  updateAccount: (args: {
    data: AccountUpdateInput;
    where: AccountWhereUniqueInput;
  }) => AccountPromise;
  updateManyAccounts: (args: {
    data: AccountUpdateManyMutationInput;
    where?: AccountWhereInput;
  }) => BatchPayloadPromise;
  upsertAccount: (args: {
    where: AccountWhereUniqueInput;
    create: AccountCreateInput;
    update: AccountUpdateInput;
  }) => AccountPromise;
  deleteAccount: (where: AccountWhereUniqueInput) => AccountPromise;
  deleteManyAccounts: (where?: AccountWhereInput) => BatchPayloadPromise;
  createAccountCustomField: (
    data: AccountCustomFieldCreateInput
  ) => AccountCustomFieldPromise;
  updateAccountCustomField: (args: {
    data: AccountCustomFieldUpdateInput;
    where: AccountCustomFieldWhereUniqueInput;
  }) => AccountCustomFieldPromise;
  updateManyAccountCustomFields: (args: {
    data: AccountCustomFieldUpdateManyMutationInput;
    where?: AccountCustomFieldWhereInput;
  }) => BatchPayloadPromise;
  upsertAccountCustomField: (args: {
    where: AccountCustomFieldWhereUniqueInput;
    create: AccountCustomFieldCreateInput;
    update: AccountCustomFieldUpdateInput;
  }) => AccountCustomFieldPromise;
  deleteAccountCustomField: (
    where: AccountCustomFieldWhereUniqueInput
  ) => AccountCustomFieldPromise;
  deleteManyAccountCustomFields: (
    where?: AccountCustomFieldWhereInput
  ) => BatchPayloadPromise;
  createAccountCustomValue: (
    data: AccountCustomValueCreateInput
  ) => AccountCustomValuePromise;
  updateAccountCustomValue: (args: {
    data: AccountCustomValueUpdateInput;
    where: AccountCustomValueWhereUniqueInput;
  }) => AccountCustomValuePromise;
  updateManyAccountCustomValues: (args: {
    data: AccountCustomValueUpdateManyMutationInput;
    where?: AccountCustomValueWhereInput;
  }) => BatchPayloadPromise;
  upsertAccountCustomValue: (args: {
    where: AccountCustomValueWhereUniqueInput;
    create: AccountCustomValueCreateInput;
    update: AccountCustomValueUpdateInput;
  }) => AccountCustomValuePromise;
  deleteAccountCustomValue: (
    where: AccountCustomValueWhereUniqueInput
  ) => AccountCustomValuePromise;
  deleteManyAccountCustomValues: (
    where?: AccountCustomValueWhereInput
  ) => BatchPayloadPromise;
  createAdmin: (data: AdminCreateInput) => AdminPromise;
  updateAdmin: (args: {
    data: AdminUpdateInput;
    where: AdminWhereUniqueInput;
  }) => AdminPromise;
  updateManyAdmins: (args: {
    data: AdminUpdateManyMutationInput;
    where?: AdminWhereInput;
  }) => BatchPayloadPromise;
  upsertAdmin: (args: {
    where: AdminWhereUniqueInput;
    create: AdminCreateInput;
    update: AdminUpdateInput;
  }) => AdminPromise;
  deleteAdmin: (where: AdminWhereUniqueInput) => AdminPromise;
  deleteManyAdmins: (where?: AdminWhereInput) => BatchPayloadPromise;
  createContact: (data: ContactCreateInput) => ContactPromise;
  updateContact: (args: {
    data: ContactUpdateInput;
    where: ContactWhereUniqueInput;
  }) => ContactPromise;
  updateManyContacts: (args: {
    data: ContactUpdateManyMutationInput;
    where?: ContactWhereInput;
  }) => BatchPayloadPromise;
  upsertContact: (args: {
    where: ContactWhereUniqueInput;
    create: ContactCreateInput;
    update: ContactUpdateInput;
  }) => ContactPromise;
  deleteContact: (where: ContactWhereUniqueInput) => ContactPromise;
  deleteManyContacts: (where?: ContactWhereInput) => BatchPayloadPromise;
  createContactCustomField: (
    data: ContactCustomFieldCreateInput
  ) => ContactCustomFieldPromise;
  updateContactCustomField: (args: {
    data: ContactCustomFieldUpdateInput;
    where: ContactCustomFieldWhereUniqueInput;
  }) => ContactCustomFieldPromise;
  updateManyContactCustomFields: (args: {
    data: ContactCustomFieldUpdateManyMutationInput;
    where?: ContactCustomFieldWhereInput;
  }) => BatchPayloadPromise;
  upsertContactCustomField: (args: {
    where: ContactCustomFieldWhereUniqueInput;
    create: ContactCustomFieldCreateInput;
    update: ContactCustomFieldUpdateInput;
  }) => ContactCustomFieldPromise;
  deleteContactCustomField: (
    where: ContactCustomFieldWhereUniqueInput
  ) => ContactCustomFieldPromise;
  deleteManyContactCustomFields: (
    where?: ContactCustomFieldWhereInput
  ) => BatchPayloadPromise;
  createContactCustomValue: (
    data: ContactCustomValueCreateInput
  ) => ContactCustomValuePromise;
  updateContactCustomValue: (args: {
    data: ContactCustomValueUpdateInput;
    where: ContactCustomValueWhereUniqueInput;
  }) => ContactCustomValuePromise;
  updateManyContactCustomValues: (args: {
    data: ContactCustomValueUpdateManyMutationInput;
    where?: ContactCustomValueWhereInput;
  }) => BatchPayloadPromise;
  upsertContactCustomValue: (args: {
    where: ContactCustomValueWhereUniqueInput;
    create: ContactCustomValueCreateInput;
    update: ContactCustomValueUpdateInput;
  }) => ContactCustomValuePromise;
  deleteContactCustomValue: (
    where: ContactCustomValueWhereUniqueInput
  ) => ContactCustomValuePromise;
  deleteManyContactCustomValues: (
    where?: ContactCustomValueWhereInput
  ) => BatchPayloadPromise;
  createJob: (data: JobCreateInput) => JobPromise;
  updateJob: (args: {
    data: JobUpdateInput;
    where: JobWhereUniqueInput;
  }) => JobPromise;
  updateManyJobs: (args: {
    data: JobUpdateManyMutationInput;
    where?: JobWhereInput;
  }) => BatchPayloadPromise;
  upsertJob: (args: {
    where: JobWhereUniqueInput;
    create: JobCreateInput;
    update: JobUpdateInput;
  }) => JobPromise;
  deleteJob: (where: JobWhereUniqueInput) => JobPromise;
  deleteManyJobs: (where?: JobWhereInput) => BatchPayloadPromise;
  createMigration: (data: MigrationCreateInput) => MigrationPromise;
  updateMigration: (args: {
    data: MigrationUpdateInput;
    where: MigrationWhereUniqueInput;
  }) => MigrationPromise;
  updateManyMigrations: (args: {
    data: MigrationUpdateManyMutationInput;
    where?: MigrationWhereInput;
  }) => BatchPayloadPromise;
  upsertMigration: (args: {
    where: MigrationWhereUniqueInput;
    create: MigrationCreateInput;
    update: MigrationUpdateInput;
  }) => MigrationPromise;
  deleteMigration: (where: MigrationWhereUniqueInput) => MigrationPromise;
  deleteManyMigrations: (where?: MigrationWhereInput) => BatchPayloadPromise;
  createOrg: (data: OrgCreateInput) => OrgPromise;
  updateOrg: (args: {
    data: OrgUpdateInput;
    where: OrgWhereUniqueInput;
  }) => OrgPromise;
  updateManyOrgs: (args: {
    data: OrgUpdateManyMutationInput;
    where?: OrgWhereInput;
  }) => BatchPayloadPromise;
  upsertOrg: (args: {
    where: OrgWhereUniqueInput;
    create: OrgCreateInput;
    update: OrgUpdateInput;
  }) => OrgPromise;
  deleteOrg: (where: OrgWhereUniqueInput) => OrgPromise;
  deleteManyOrgs: (where?: OrgWhereInput) => BatchPayloadPromise;
  createPasswordReset: (data: PasswordResetCreateInput) => PasswordResetPromise;
  updateManyPasswordResets: (args: {
    data: PasswordResetUpdateManyMutationInput;
    where?: PasswordResetWhereInput;
  }) => BatchPayloadPromise;
  deleteManyPasswordResets: (
    where?: PasswordResetWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  account: (
    where?: AccountSubscriptionWhereInput
  ) => AccountSubscriptionPayloadSubscription;
  accountCustomField: (
    where?: AccountCustomFieldSubscriptionWhereInput
  ) => AccountCustomFieldSubscriptionPayloadSubscription;
  accountCustomValue: (
    where?: AccountCustomValueSubscriptionWhereInput
  ) => AccountCustomValueSubscriptionPayloadSubscription;
  admin: (
    where?: AdminSubscriptionWhereInput
  ) => AdminSubscriptionPayloadSubscription;
  contact: (
    where?: ContactSubscriptionWhereInput
  ) => ContactSubscriptionPayloadSubscription;
  contactCustomField: (
    where?: ContactCustomFieldSubscriptionWhereInput
  ) => ContactCustomFieldSubscriptionPayloadSubscription;
  contactCustomValue: (
    where?: ContactCustomValueSubscriptionWhereInput
  ) => ContactCustomValueSubscriptionPayloadSubscription;
  job: (
    where?: JobSubscriptionWhereInput
  ) => JobSubscriptionPayloadSubscription;
  migration: (
    where?: MigrationSubscriptionWhereInput
  ) => MigrationSubscriptionPayloadSubscription;
  org: (
    where?: OrgSubscriptionWhereInput
  ) => OrgSubscriptionPayloadSubscription;
  passwordReset: (
    where?: PasswordResetSubscriptionWhereInput
  ) => PasswordResetSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type UsersRoleEnum =
  | "admin"
  | "guest"
  | "manager"
  | "sys_admin"
  | "user";

export type AccountCustomValueOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "value_ASC"
  | "value_DESC";

export type AccountCustomFieldOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "fieldName_ASC"
  | "fieldName_DESC"
  | "label_ASC"
  | "label_DESC"
  | "max_ASC"
  | "max_DESC"
  | "min_ASC"
  | "min_DESC"
  | "options_ASC"
  | "options_DESC"
  | "placeholder_ASC"
  | "placeholder_DESC"
  | "required_ASC"
  | "required_DESC"
  | "tag_ASC"
  | "tag_DESC"
  | "type_ASC"
  | "type_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AccountOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "city_ASC"
  | "city_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "primaryEmail_ASC"
  | "primaryEmail_DESC"
  | "primaryPhone_ASC"
  | "primaryPhone_DESC"
  | "state_ASC"
  | "state_DESC"
  | "streetAddress_ASC"
  | "streetAddress_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "zip_ASC"
  | "zip_DESC";

export type ContactCustomFieldOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "fieldName_ASC"
  | "fieldName_DESC"
  | "label_ASC"
  | "label_DESC"
  | "max_ASC"
  | "max_DESC"
  | "min_ASC"
  | "min_DESC"
  | "options_ASC"
  | "options_DESC"
  | "placeholder_ASC"
  | "placeholder_DESC"
  | "required_ASC"
  | "required_DESC"
  | "tag_ASC"
  | "tag_DESC"
  | "type_ASC"
  | "type_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ContactCustomValueOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "value_ASC"
  | "value_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "emailVerifiedAt_ASC"
  | "emailVerifiedAt_DESC"
  | "orgId_ASC"
  | "orgId_DESC"
  | "password_ASC"
  | "password_DESC"
  | "rememberToken_ASC"
  | "rememberToken_DESC"
  | "role_ASC"
  | "role_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ContactOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "city_ASC"
  | "city_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "first_ASC"
  | "first_DESC"
  | "last_ASC"
  | "last_DESC"
  | "middle_ASC"
  | "middle_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "state_ASC"
  | "state_DESC"
  | "streetAddress_ASC"
  | "streetAddress_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "zip_ASC"
  | "zip_DESC";

export type AdminOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "address_ASC"
  | "address_DESC"
  | "city_ASC"
  | "city_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "first_ASC"
  | "first_DESC"
  | "isSuper_ASC"
  | "isSuper_DESC"
  | "last_ASC"
  | "last_DESC"
  | "password_ASC"
  | "password_DESC"
  | "rememberToken_ASC"
  | "rememberToken_DESC"
  | "state_ASC"
  | "state_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "zip_ASC"
  | "zip_DESC";

export type JobOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "attempts_ASC"
  | "attempts_DESC"
  | "availableAt_ASC"
  | "availableAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "payload_ASC"
  | "payload_DESC"
  | "queue_ASC"
  | "queue_DESC"
  | "reservedAt_ASC"
  | "reservedAt_DESC";

export type MigrationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "batch_ASC"
  | "batch_DESC"
  | "migration_ASC"
  | "migration_DESC";

export type OrgOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "primaryEmail_ASC"
  | "primaryEmail_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PasswordResetOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "token_ASC"
  | "token_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AccountWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface AccountCustomValueWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  account?: Maybe<AccountWhereInput>;
  accountCustomField?: Maybe<AccountCustomFieldWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  AND?: Maybe<AccountCustomValueWhereInput[] | AccountCustomValueWhereInput>;
  OR?: Maybe<AccountCustomValueWhereInput[] | AccountCustomValueWhereInput>;
  NOT?: Maybe<AccountCustomValueWhereInput[] | AccountCustomValueWhereInput>;
}

export interface AccountWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  accountCustomValues_every?: Maybe<AccountCustomValueWhereInput>;
  accountCustomValues_some?: Maybe<AccountCustomValueWhereInput>;
  accountCustomValues_none?: Maybe<AccountCustomValueWhereInput>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  org?: Maybe<OrgWhereInput>;
  primaryContact?: Maybe<ContactWhereInput>;
  primaryEmail?: Maybe<String>;
  primaryEmail_not?: Maybe<String>;
  primaryEmail_in?: Maybe<String[] | String>;
  primaryEmail_not_in?: Maybe<String[] | String>;
  primaryEmail_lt?: Maybe<String>;
  primaryEmail_lte?: Maybe<String>;
  primaryEmail_gt?: Maybe<String>;
  primaryEmail_gte?: Maybe<String>;
  primaryEmail_contains?: Maybe<String>;
  primaryEmail_not_contains?: Maybe<String>;
  primaryEmail_starts_with?: Maybe<String>;
  primaryEmail_not_starts_with?: Maybe<String>;
  primaryEmail_ends_with?: Maybe<String>;
  primaryEmail_not_ends_with?: Maybe<String>;
  primaryPhone?: Maybe<String>;
  primaryPhone_not?: Maybe<String>;
  primaryPhone_in?: Maybe<String[] | String>;
  primaryPhone_not_in?: Maybe<String[] | String>;
  primaryPhone_lt?: Maybe<String>;
  primaryPhone_lte?: Maybe<String>;
  primaryPhone_gt?: Maybe<String>;
  primaryPhone_gte?: Maybe<String>;
  primaryPhone_contains?: Maybe<String>;
  primaryPhone_not_contains?: Maybe<String>;
  primaryPhone_starts_with?: Maybe<String>;
  primaryPhone_not_starts_with?: Maybe<String>;
  primaryPhone_ends_with?: Maybe<String>;
  primaryPhone_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  streetAddress?: Maybe<String>;
  streetAddress_not?: Maybe<String>;
  streetAddress_in?: Maybe<String[] | String>;
  streetAddress_not_in?: Maybe<String[] | String>;
  streetAddress_lt?: Maybe<String>;
  streetAddress_lte?: Maybe<String>;
  streetAddress_gt?: Maybe<String>;
  streetAddress_gte?: Maybe<String>;
  streetAddress_contains?: Maybe<String>;
  streetAddress_not_contains?: Maybe<String>;
  streetAddress_starts_with?: Maybe<String>;
  streetAddress_not_starts_with?: Maybe<String>;
  streetAddress_ends_with?: Maybe<String>;
  streetAddress_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  zip?: Maybe<String>;
  zip_not?: Maybe<String>;
  zip_in?: Maybe<String[] | String>;
  zip_not_in?: Maybe<String[] | String>;
  zip_lt?: Maybe<String>;
  zip_lte?: Maybe<String>;
  zip_gt?: Maybe<String>;
  zip_gte?: Maybe<String>;
  zip_contains?: Maybe<String>;
  zip_not_contains?: Maybe<String>;
  zip_starts_with?: Maybe<String>;
  zip_not_starts_with?: Maybe<String>;
  zip_ends_with?: Maybe<String>;
  zip_not_ends_with?: Maybe<String>;
  AND?: Maybe<AccountWhereInput[] | AccountWhereInput>;
  OR?: Maybe<AccountWhereInput[] | AccountWhereInput>;
  NOT?: Maybe<AccountWhereInput[] | AccountWhereInput>;
}

export interface OrgWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  accountCustomFields_every?: Maybe<AccountCustomFieldWhereInput>;
  accountCustomFields_some?: Maybe<AccountCustomFieldWhereInput>;
  accountCustomFields_none?: Maybe<AccountCustomFieldWhereInput>;
  accounts_every?: Maybe<AccountWhereInput>;
  accounts_some?: Maybe<AccountWhereInput>;
  accounts_none?: Maybe<AccountWhereInput>;
  contactCustomFields_every?: Maybe<ContactCustomFieldWhereInput>;
  contactCustomFields_some?: Maybe<ContactCustomFieldWhereInput>;
  contactCustomFields_none?: Maybe<ContactCustomFieldWhereInput>;
  contactCustomValues_every?: Maybe<ContactCustomValueWhereInput>;
  contactCustomValues_some?: Maybe<ContactCustomValueWhereInput>;
  contactCustomValues_none?: Maybe<ContactCustomValueWhereInput>;
  contacts_every?: Maybe<ContactWhereInput>;
  contacts_some?: Maybe<ContactWhereInput>;
  contacts_none?: Maybe<ContactWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  primaryEmail?: Maybe<String>;
  primaryEmail_not?: Maybe<String>;
  primaryEmail_in?: Maybe<String[] | String>;
  primaryEmail_not_in?: Maybe<String[] | String>;
  primaryEmail_lt?: Maybe<String>;
  primaryEmail_lte?: Maybe<String>;
  primaryEmail_gt?: Maybe<String>;
  primaryEmail_gte?: Maybe<String>;
  primaryEmail_contains?: Maybe<String>;
  primaryEmail_not_contains?: Maybe<String>;
  primaryEmail_starts_with?: Maybe<String>;
  primaryEmail_not_starts_with?: Maybe<String>;
  primaryEmail_ends_with?: Maybe<String>;
  primaryEmail_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<OrgWhereInput[] | OrgWhereInput>;
  OR?: Maybe<OrgWhereInput[] | OrgWhereInput>;
  NOT?: Maybe<OrgWhereInput[] | OrgWhereInput>;
}

export interface AccountCustomFieldWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  accountCustomValues_every?: Maybe<AccountCustomValueWhereInput>;
  accountCustomValues_some?: Maybe<AccountCustomValueWhereInput>;
  accountCustomValues_none?: Maybe<AccountCustomValueWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  fieldName?: Maybe<String>;
  fieldName_not?: Maybe<String>;
  fieldName_in?: Maybe<String[] | String>;
  fieldName_not_in?: Maybe<String[] | String>;
  fieldName_lt?: Maybe<String>;
  fieldName_lte?: Maybe<String>;
  fieldName_gt?: Maybe<String>;
  fieldName_gte?: Maybe<String>;
  fieldName_contains?: Maybe<String>;
  fieldName_not_contains?: Maybe<String>;
  fieldName_starts_with?: Maybe<String>;
  fieldName_not_starts_with?: Maybe<String>;
  fieldName_ends_with?: Maybe<String>;
  fieldName_not_ends_with?: Maybe<String>;
  label?: Maybe<String>;
  label_not?: Maybe<String>;
  label_in?: Maybe<String[] | String>;
  label_not_in?: Maybe<String[] | String>;
  label_lt?: Maybe<String>;
  label_lte?: Maybe<String>;
  label_gt?: Maybe<String>;
  label_gte?: Maybe<String>;
  label_contains?: Maybe<String>;
  label_not_contains?: Maybe<String>;
  label_starts_with?: Maybe<String>;
  label_not_starts_with?: Maybe<String>;
  label_ends_with?: Maybe<String>;
  label_not_ends_with?: Maybe<String>;
  max?: Maybe<String>;
  max_not?: Maybe<String>;
  max_in?: Maybe<String[] | String>;
  max_not_in?: Maybe<String[] | String>;
  max_lt?: Maybe<String>;
  max_lte?: Maybe<String>;
  max_gt?: Maybe<String>;
  max_gte?: Maybe<String>;
  max_contains?: Maybe<String>;
  max_not_contains?: Maybe<String>;
  max_starts_with?: Maybe<String>;
  max_not_starts_with?: Maybe<String>;
  max_ends_with?: Maybe<String>;
  max_not_ends_with?: Maybe<String>;
  min?: Maybe<String>;
  min_not?: Maybe<String>;
  min_in?: Maybe<String[] | String>;
  min_not_in?: Maybe<String[] | String>;
  min_lt?: Maybe<String>;
  min_lte?: Maybe<String>;
  min_gt?: Maybe<String>;
  min_gte?: Maybe<String>;
  min_contains?: Maybe<String>;
  min_not_contains?: Maybe<String>;
  min_starts_with?: Maybe<String>;
  min_not_starts_with?: Maybe<String>;
  min_ends_with?: Maybe<String>;
  min_not_ends_with?: Maybe<String>;
  org?: Maybe<OrgWhereInput>;
  placeholder?: Maybe<String>;
  placeholder_not?: Maybe<String>;
  placeholder_in?: Maybe<String[] | String>;
  placeholder_not_in?: Maybe<String[] | String>;
  placeholder_lt?: Maybe<String>;
  placeholder_lte?: Maybe<String>;
  placeholder_gt?: Maybe<String>;
  placeholder_gte?: Maybe<String>;
  placeholder_contains?: Maybe<String>;
  placeholder_not_contains?: Maybe<String>;
  placeholder_starts_with?: Maybe<String>;
  placeholder_not_starts_with?: Maybe<String>;
  placeholder_ends_with?: Maybe<String>;
  placeholder_not_ends_with?: Maybe<String>;
  required?: Maybe<Boolean>;
  required_not?: Maybe<Boolean>;
  tag?: Maybe<String>;
  tag_not?: Maybe<String>;
  tag_in?: Maybe<String[] | String>;
  tag_not_in?: Maybe<String[] | String>;
  tag_lt?: Maybe<String>;
  tag_lte?: Maybe<String>;
  tag_gt?: Maybe<String>;
  tag_gte?: Maybe<String>;
  tag_contains?: Maybe<String>;
  tag_not_contains?: Maybe<String>;
  tag_starts_with?: Maybe<String>;
  tag_not_starts_with?: Maybe<String>;
  tag_ends_with?: Maybe<String>;
  tag_not_ends_with?: Maybe<String>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AccountCustomFieldWhereInput[] | AccountCustomFieldWhereInput>;
  OR?: Maybe<AccountCustomFieldWhereInput[] | AccountCustomFieldWhereInput>;
  NOT?: Maybe<AccountCustomFieldWhereInput[] | AccountCustomFieldWhereInput>;
}

export interface ContactCustomFieldWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  contactCustomValues_every?: Maybe<ContactCustomValueWhereInput>;
  contactCustomValues_some?: Maybe<ContactCustomValueWhereInput>;
  contactCustomValues_none?: Maybe<ContactCustomValueWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  fieldName?: Maybe<String>;
  fieldName_not?: Maybe<String>;
  fieldName_in?: Maybe<String[] | String>;
  fieldName_not_in?: Maybe<String[] | String>;
  fieldName_lt?: Maybe<String>;
  fieldName_lte?: Maybe<String>;
  fieldName_gt?: Maybe<String>;
  fieldName_gte?: Maybe<String>;
  fieldName_contains?: Maybe<String>;
  fieldName_not_contains?: Maybe<String>;
  fieldName_starts_with?: Maybe<String>;
  fieldName_not_starts_with?: Maybe<String>;
  fieldName_ends_with?: Maybe<String>;
  fieldName_not_ends_with?: Maybe<String>;
  label?: Maybe<String>;
  label_not?: Maybe<String>;
  label_in?: Maybe<String[] | String>;
  label_not_in?: Maybe<String[] | String>;
  label_lt?: Maybe<String>;
  label_lte?: Maybe<String>;
  label_gt?: Maybe<String>;
  label_gte?: Maybe<String>;
  label_contains?: Maybe<String>;
  label_not_contains?: Maybe<String>;
  label_starts_with?: Maybe<String>;
  label_not_starts_with?: Maybe<String>;
  label_ends_with?: Maybe<String>;
  label_not_ends_with?: Maybe<String>;
  max?: Maybe<String>;
  max_not?: Maybe<String>;
  max_in?: Maybe<String[] | String>;
  max_not_in?: Maybe<String[] | String>;
  max_lt?: Maybe<String>;
  max_lte?: Maybe<String>;
  max_gt?: Maybe<String>;
  max_gte?: Maybe<String>;
  max_contains?: Maybe<String>;
  max_not_contains?: Maybe<String>;
  max_starts_with?: Maybe<String>;
  max_not_starts_with?: Maybe<String>;
  max_ends_with?: Maybe<String>;
  max_not_ends_with?: Maybe<String>;
  min?: Maybe<String>;
  min_not?: Maybe<String>;
  min_in?: Maybe<String[] | String>;
  min_not_in?: Maybe<String[] | String>;
  min_lt?: Maybe<String>;
  min_lte?: Maybe<String>;
  min_gt?: Maybe<String>;
  min_gte?: Maybe<String>;
  min_contains?: Maybe<String>;
  min_not_contains?: Maybe<String>;
  min_starts_with?: Maybe<String>;
  min_not_starts_with?: Maybe<String>;
  min_ends_with?: Maybe<String>;
  min_not_ends_with?: Maybe<String>;
  org?: Maybe<OrgWhereInput>;
  placeholder?: Maybe<String>;
  placeholder_not?: Maybe<String>;
  placeholder_in?: Maybe<String[] | String>;
  placeholder_not_in?: Maybe<String[] | String>;
  placeholder_lt?: Maybe<String>;
  placeholder_lte?: Maybe<String>;
  placeholder_gt?: Maybe<String>;
  placeholder_gte?: Maybe<String>;
  placeholder_contains?: Maybe<String>;
  placeholder_not_contains?: Maybe<String>;
  placeholder_starts_with?: Maybe<String>;
  placeholder_not_starts_with?: Maybe<String>;
  placeholder_ends_with?: Maybe<String>;
  placeholder_not_ends_with?: Maybe<String>;
  required?: Maybe<Boolean>;
  required_not?: Maybe<Boolean>;
  tag?: Maybe<String>;
  tag_not?: Maybe<String>;
  tag_in?: Maybe<String[] | String>;
  tag_not_in?: Maybe<String[] | String>;
  tag_lt?: Maybe<String>;
  tag_lte?: Maybe<String>;
  tag_gt?: Maybe<String>;
  tag_gte?: Maybe<String>;
  tag_contains?: Maybe<String>;
  tag_not_contains?: Maybe<String>;
  tag_starts_with?: Maybe<String>;
  tag_not_starts_with?: Maybe<String>;
  tag_ends_with?: Maybe<String>;
  tag_not_ends_with?: Maybe<String>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ContactCustomFieldWhereInput[] | ContactCustomFieldWhereInput>;
  OR?: Maybe<ContactCustomFieldWhereInput[] | ContactCustomFieldWhereInput>;
  NOT?: Maybe<ContactCustomFieldWhereInput[] | ContactCustomFieldWhereInput>;
}

export interface ContactCustomValueWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  contact?: Maybe<ContactWhereInput>;
  contactCustomField?: Maybe<ContactCustomFieldWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  org?: Maybe<OrgWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  AND?: Maybe<ContactCustomValueWhereInput[] | ContactCustomValueWhereInput>;
  OR?: Maybe<ContactCustomValueWhereInput[] | ContactCustomValueWhereInput>;
  NOT?: Maybe<ContactCustomValueWhereInput[] | ContactCustomValueWhereInput>;
}

export interface ContactWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  accounts_every?: Maybe<AccountWhereInput>;
  accounts_some?: Maybe<AccountWhereInput>;
  accounts_none?: Maybe<AccountWhereInput>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  contactCustomValues_every?: Maybe<ContactCustomValueWhereInput>;
  contactCustomValues_some?: Maybe<ContactCustomValueWhereInput>;
  contactCustomValues_none?: Maybe<ContactCustomValueWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  first?: Maybe<String>;
  first_not?: Maybe<String>;
  first_in?: Maybe<String[] | String>;
  first_not_in?: Maybe<String[] | String>;
  first_lt?: Maybe<String>;
  first_lte?: Maybe<String>;
  first_gt?: Maybe<String>;
  first_gte?: Maybe<String>;
  first_contains?: Maybe<String>;
  first_not_contains?: Maybe<String>;
  first_starts_with?: Maybe<String>;
  first_not_starts_with?: Maybe<String>;
  first_ends_with?: Maybe<String>;
  first_not_ends_with?: Maybe<String>;
  last?: Maybe<String>;
  last_not?: Maybe<String>;
  last_in?: Maybe<String[] | String>;
  last_not_in?: Maybe<String[] | String>;
  last_lt?: Maybe<String>;
  last_lte?: Maybe<String>;
  last_gt?: Maybe<String>;
  last_gte?: Maybe<String>;
  last_contains?: Maybe<String>;
  last_not_contains?: Maybe<String>;
  last_starts_with?: Maybe<String>;
  last_not_starts_with?: Maybe<String>;
  last_ends_with?: Maybe<String>;
  last_not_ends_with?: Maybe<String>;
  middle?: Maybe<String>;
  middle_not?: Maybe<String>;
  middle_in?: Maybe<String[] | String>;
  middle_not_in?: Maybe<String[] | String>;
  middle_lt?: Maybe<String>;
  middle_lte?: Maybe<String>;
  middle_gt?: Maybe<String>;
  middle_gte?: Maybe<String>;
  middle_contains?: Maybe<String>;
  middle_not_contains?: Maybe<String>;
  middle_starts_with?: Maybe<String>;
  middle_not_starts_with?: Maybe<String>;
  middle_ends_with?: Maybe<String>;
  middle_not_ends_with?: Maybe<String>;
  org?: Maybe<OrgWhereInput>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  streetAddress?: Maybe<String>;
  streetAddress_not?: Maybe<String>;
  streetAddress_in?: Maybe<String[] | String>;
  streetAddress_not_in?: Maybe<String[] | String>;
  streetAddress_lt?: Maybe<String>;
  streetAddress_lte?: Maybe<String>;
  streetAddress_gt?: Maybe<String>;
  streetAddress_gte?: Maybe<String>;
  streetAddress_contains?: Maybe<String>;
  streetAddress_not_contains?: Maybe<String>;
  streetAddress_starts_with?: Maybe<String>;
  streetAddress_not_starts_with?: Maybe<String>;
  streetAddress_ends_with?: Maybe<String>;
  streetAddress_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  users_every?: Maybe<UserWhereInput>;
  users_some?: Maybe<UserWhereInput>;
  users_none?: Maybe<UserWhereInput>;
  zip?: Maybe<String>;
  zip_not?: Maybe<String>;
  zip_in?: Maybe<String[] | String>;
  zip_not_in?: Maybe<String[] | String>;
  zip_lt?: Maybe<String>;
  zip_lte?: Maybe<String>;
  zip_gt?: Maybe<String>;
  zip_gte?: Maybe<String>;
  zip_contains?: Maybe<String>;
  zip_not_contains?: Maybe<String>;
  zip_starts_with?: Maybe<String>;
  zip_not_starts_with?: Maybe<String>;
  zip_ends_with?: Maybe<String>;
  zip_not_ends_with?: Maybe<String>;
  AND?: Maybe<ContactWhereInput[] | ContactWhereInput>;
  OR?: Maybe<ContactWhereInput[] | ContactWhereInput>;
  NOT?: Maybe<ContactWhereInput[] | ContactWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  contact?: Maybe<ContactWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  emailVerifiedAt?: Maybe<DateTimeInput>;
  emailVerifiedAt_not?: Maybe<DateTimeInput>;
  emailVerifiedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  emailVerifiedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  emailVerifiedAt_lt?: Maybe<DateTimeInput>;
  emailVerifiedAt_lte?: Maybe<DateTimeInput>;
  emailVerifiedAt_gt?: Maybe<DateTimeInput>;
  emailVerifiedAt_gte?: Maybe<DateTimeInput>;
  orgId?: Maybe<Int>;
  orgId_not?: Maybe<Int>;
  orgId_in?: Maybe<Int[] | Int>;
  orgId_not_in?: Maybe<Int[] | Int>;
  orgId_lt?: Maybe<Int>;
  orgId_lte?: Maybe<Int>;
  orgId_gt?: Maybe<Int>;
  orgId_gte?: Maybe<Int>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  rememberToken?: Maybe<String>;
  rememberToken_not?: Maybe<String>;
  rememberToken_in?: Maybe<String[] | String>;
  rememberToken_not_in?: Maybe<String[] | String>;
  rememberToken_lt?: Maybe<String>;
  rememberToken_lte?: Maybe<String>;
  rememberToken_gt?: Maybe<String>;
  rememberToken_gte?: Maybe<String>;
  rememberToken_contains?: Maybe<String>;
  rememberToken_not_contains?: Maybe<String>;
  rememberToken_starts_with?: Maybe<String>;
  rememberToken_not_starts_with?: Maybe<String>;
  rememberToken_ends_with?: Maybe<String>;
  rememberToken_not_ends_with?: Maybe<String>;
  role?: Maybe<UsersRoleEnum>;
  role_not?: Maybe<UsersRoleEnum>;
  role_in?: Maybe<UsersRoleEnum[] | UsersRoleEnum>;
  role_not_in?: Maybe<UsersRoleEnum[] | UsersRoleEnum>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export type AccountCustomFieldWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type AccountCustomValueWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type AdminWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
  email?: Maybe<String>;
}>;

export interface AdminWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  first?: Maybe<String>;
  first_not?: Maybe<String>;
  first_in?: Maybe<String[] | String>;
  first_not_in?: Maybe<String[] | String>;
  first_lt?: Maybe<String>;
  first_lte?: Maybe<String>;
  first_gt?: Maybe<String>;
  first_gte?: Maybe<String>;
  first_contains?: Maybe<String>;
  first_not_contains?: Maybe<String>;
  first_starts_with?: Maybe<String>;
  first_not_starts_with?: Maybe<String>;
  first_ends_with?: Maybe<String>;
  first_not_ends_with?: Maybe<String>;
  isSuper?: Maybe<Boolean>;
  isSuper_not?: Maybe<Boolean>;
  last?: Maybe<String>;
  last_not?: Maybe<String>;
  last_in?: Maybe<String[] | String>;
  last_not_in?: Maybe<String[] | String>;
  last_lt?: Maybe<String>;
  last_lte?: Maybe<String>;
  last_gt?: Maybe<String>;
  last_gte?: Maybe<String>;
  last_contains?: Maybe<String>;
  last_not_contains?: Maybe<String>;
  last_starts_with?: Maybe<String>;
  last_not_starts_with?: Maybe<String>;
  last_ends_with?: Maybe<String>;
  last_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  rememberToken?: Maybe<String>;
  rememberToken_not?: Maybe<String>;
  rememberToken_in?: Maybe<String[] | String>;
  rememberToken_not_in?: Maybe<String[] | String>;
  rememberToken_lt?: Maybe<String>;
  rememberToken_lte?: Maybe<String>;
  rememberToken_gt?: Maybe<String>;
  rememberToken_gte?: Maybe<String>;
  rememberToken_contains?: Maybe<String>;
  rememberToken_not_contains?: Maybe<String>;
  rememberToken_starts_with?: Maybe<String>;
  rememberToken_not_starts_with?: Maybe<String>;
  rememberToken_ends_with?: Maybe<String>;
  rememberToken_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  zip?: Maybe<String>;
  zip_not?: Maybe<String>;
  zip_in?: Maybe<String[] | String>;
  zip_not_in?: Maybe<String[] | String>;
  zip_lt?: Maybe<String>;
  zip_lte?: Maybe<String>;
  zip_gt?: Maybe<String>;
  zip_gte?: Maybe<String>;
  zip_contains?: Maybe<String>;
  zip_not_contains?: Maybe<String>;
  zip_starts_with?: Maybe<String>;
  zip_not_starts_with?: Maybe<String>;
  zip_ends_with?: Maybe<String>;
  zip_not_ends_with?: Maybe<String>;
  AND?: Maybe<AdminWhereInput[] | AdminWhereInput>;
  OR?: Maybe<AdminWhereInput[] | AdminWhereInput>;
  NOT?: Maybe<AdminWhereInput[] | AdminWhereInput>;
}

export type ContactWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type ContactCustomFieldWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type ContactCustomValueWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type JobWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface JobWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  attempts?: Maybe<Boolean>;
  attempts_not?: Maybe<Boolean>;
  availableAt?: Maybe<Int>;
  availableAt_not?: Maybe<Int>;
  availableAt_in?: Maybe<Int[] | Int>;
  availableAt_not_in?: Maybe<Int[] | Int>;
  availableAt_lt?: Maybe<Int>;
  availableAt_lte?: Maybe<Int>;
  availableAt_gt?: Maybe<Int>;
  availableAt_gte?: Maybe<Int>;
  createdAt?: Maybe<Int>;
  createdAt_not?: Maybe<Int>;
  createdAt_in?: Maybe<Int[] | Int>;
  createdAt_not_in?: Maybe<Int[] | Int>;
  createdAt_lt?: Maybe<Int>;
  createdAt_lte?: Maybe<Int>;
  createdAt_gt?: Maybe<Int>;
  createdAt_gte?: Maybe<Int>;
  payload?: Maybe<String>;
  payload_not?: Maybe<String>;
  payload_in?: Maybe<String[] | String>;
  payload_not_in?: Maybe<String[] | String>;
  payload_lt?: Maybe<String>;
  payload_lte?: Maybe<String>;
  payload_gt?: Maybe<String>;
  payload_gte?: Maybe<String>;
  payload_contains?: Maybe<String>;
  payload_not_contains?: Maybe<String>;
  payload_starts_with?: Maybe<String>;
  payload_not_starts_with?: Maybe<String>;
  payload_ends_with?: Maybe<String>;
  payload_not_ends_with?: Maybe<String>;
  queue?: Maybe<String>;
  queue_not?: Maybe<String>;
  queue_in?: Maybe<String[] | String>;
  queue_not_in?: Maybe<String[] | String>;
  queue_lt?: Maybe<String>;
  queue_lte?: Maybe<String>;
  queue_gt?: Maybe<String>;
  queue_gte?: Maybe<String>;
  queue_contains?: Maybe<String>;
  queue_not_contains?: Maybe<String>;
  queue_starts_with?: Maybe<String>;
  queue_not_starts_with?: Maybe<String>;
  queue_ends_with?: Maybe<String>;
  queue_not_ends_with?: Maybe<String>;
  reservedAt?: Maybe<Int>;
  reservedAt_not?: Maybe<Int>;
  reservedAt_in?: Maybe<Int[] | Int>;
  reservedAt_not_in?: Maybe<Int[] | Int>;
  reservedAt_lt?: Maybe<Int>;
  reservedAt_lte?: Maybe<Int>;
  reservedAt_gt?: Maybe<Int>;
  reservedAt_gte?: Maybe<Int>;
  AND?: Maybe<JobWhereInput[] | JobWhereInput>;
  OR?: Maybe<JobWhereInput[] | JobWhereInput>;
  NOT?: Maybe<JobWhereInput[] | JobWhereInput>;
}

export type MigrationWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface MigrationWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  batch?: Maybe<Int>;
  batch_not?: Maybe<Int>;
  batch_in?: Maybe<Int[] | Int>;
  batch_not_in?: Maybe<Int[] | Int>;
  batch_lt?: Maybe<Int>;
  batch_lte?: Maybe<Int>;
  batch_gt?: Maybe<Int>;
  batch_gte?: Maybe<Int>;
  migration?: Maybe<String>;
  migration_not?: Maybe<String>;
  migration_in?: Maybe<String[] | String>;
  migration_not_in?: Maybe<String[] | String>;
  migration_lt?: Maybe<String>;
  migration_lte?: Maybe<String>;
  migration_gt?: Maybe<String>;
  migration_gte?: Maybe<String>;
  migration_contains?: Maybe<String>;
  migration_not_contains?: Maybe<String>;
  migration_starts_with?: Maybe<String>;
  migration_not_starts_with?: Maybe<String>;
  migration_ends_with?: Maybe<String>;
  migration_not_ends_with?: Maybe<String>;
  AND?: Maybe<MigrationWhereInput[] | MigrationWhereInput>;
  OR?: Maybe<MigrationWhereInput[] | MigrationWhereInput>;
  NOT?: Maybe<MigrationWhereInput[] | MigrationWhereInput>;
}

export type OrgWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface PasswordResetWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  token?: Maybe<String>;
  token_not?: Maybe<String>;
  token_in?: Maybe<String[] | String>;
  token_not_in?: Maybe<String[] | String>;
  token_lt?: Maybe<String>;
  token_lte?: Maybe<String>;
  token_gt?: Maybe<String>;
  token_gte?: Maybe<String>;
  token_contains?: Maybe<String>;
  token_not_contains?: Maybe<String>;
  token_starts_with?: Maybe<String>;
  token_not_starts_with?: Maybe<String>;
  token_ends_with?: Maybe<String>;
  token_not_ends_with?: Maybe<String>;
  AND?: Maybe<PasswordResetWhereInput[] | PasswordResetWhereInput>;
  OR?: Maybe<PasswordResetWhereInput[] | PasswordResetWhereInput>;
  NOT?: Maybe<PasswordResetWhereInput[] | PasswordResetWhereInput>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
  email?: Maybe<String>;
}>;

export interface AccountCreateInput {
  id?: Maybe<Int>;
  accountCustomValues?: Maybe<AccountCustomValueCreateManyWithoutAccountInput>;
  city: String;
  name: String;
  org: OrgCreateOneWithoutAccountsInput;
  primaryContact: ContactCreateOneWithoutAccountsInput;
  primaryEmail: String;
  primaryPhone: String;
  state: String;
  streetAddress: String;
  zip: String;
}

export interface AccountCustomValueCreateManyWithoutAccountInput {
  create?: Maybe<
    | AccountCustomValueCreateWithoutAccountInput[]
    | AccountCustomValueCreateWithoutAccountInput
  >;
  connect?: Maybe<
    AccountCustomValueWhereUniqueInput[] | AccountCustomValueWhereUniqueInput
  >;
}

export interface AccountCustomValueCreateWithoutAccountInput {
  id?: Maybe<Int>;
  accountCustomField: AccountCustomFieldCreateOneWithoutAccountCustomValuesInput;
  value: String;
}

export interface AccountCustomFieldCreateOneWithoutAccountCustomValuesInput {
  create?: Maybe<AccountCustomFieldCreateWithoutAccountCustomValuesInput>;
  connect?: Maybe<AccountCustomFieldWhereUniqueInput>;
}

export interface AccountCustomFieldCreateWithoutAccountCustomValuesInput {
  id?: Maybe<Int>;
  fieldName: String;
  label: String;
  max?: Maybe<String>;
  min?: Maybe<String>;
  options?: Maybe<Json>;
  org: OrgCreateOneWithoutAccountCustomFieldsInput;
  placeholder?: Maybe<String>;
  required: Boolean;
  tag: String;
  type?: Maybe<String>;
}

export interface OrgCreateOneWithoutAccountCustomFieldsInput {
  create?: Maybe<OrgCreateWithoutAccountCustomFieldsInput>;
  connect?: Maybe<OrgWhereUniqueInput>;
}

export interface OrgCreateWithoutAccountCustomFieldsInput {
  id?: Maybe<Int>;
  accounts?: Maybe<AccountCreateManyWithoutOrgInput>;
  contactCustomFields?: Maybe<ContactCustomFieldCreateManyWithoutOrgInput>;
  contactCustomValues?: Maybe<ContactCustomValueCreateManyWithoutOrgInput>;
  contacts?: Maybe<ContactCreateManyWithoutOrgInput>;
  name: String;
  phone: String;
  primaryEmail: String;
}

export interface AccountCreateManyWithoutOrgInput {
  create?: Maybe<AccountCreateWithoutOrgInput[] | AccountCreateWithoutOrgInput>;
  connect?: Maybe<AccountWhereUniqueInput[] | AccountWhereUniqueInput>;
}

export interface AccountCreateWithoutOrgInput {
  id?: Maybe<Int>;
  accountCustomValues?: Maybe<AccountCustomValueCreateManyWithoutAccountInput>;
  city: String;
  name: String;
  primaryContact: ContactCreateOneWithoutAccountsInput;
  primaryEmail: String;
  primaryPhone: String;
  state: String;
  streetAddress: String;
  zip: String;
}

export interface ContactCreateOneWithoutAccountsInput {
  create?: Maybe<ContactCreateWithoutAccountsInput>;
  connect?: Maybe<ContactWhereUniqueInput>;
}

export interface ContactCreateWithoutAccountsInput {
  id?: Maybe<Int>;
  city?: Maybe<String>;
  contactCustomValues?: Maybe<ContactCustomValueCreateManyWithoutContactInput>;
  email?: Maybe<String>;
  first: String;
  last: String;
  middle?: Maybe<String>;
  org: OrgCreateOneWithoutContactsInput;
  phone?: Maybe<String>;
  state: String;
  streetAddress?: Maybe<String>;
  users?: Maybe<UserCreateManyWithoutContactInput>;
  zip?: Maybe<String>;
}

export interface ContactCustomValueCreateManyWithoutContactInput {
  create?: Maybe<
    | ContactCustomValueCreateWithoutContactInput[]
    | ContactCustomValueCreateWithoutContactInput
  >;
  connect?: Maybe<
    ContactCustomValueWhereUniqueInput[] | ContactCustomValueWhereUniqueInput
  >;
}

export interface ContactCustomValueCreateWithoutContactInput {
  id?: Maybe<Int>;
  contactCustomField: ContactCustomFieldCreateOneWithoutContactCustomValuesInput;
  org: OrgCreateOneWithoutContactCustomValuesInput;
  value: String;
}

export interface ContactCustomFieldCreateOneWithoutContactCustomValuesInput {
  create?: Maybe<ContactCustomFieldCreateWithoutContactCustomValuesInput>;
  connect?: Maybe<ContactCustomFieldWhereUniqueInput>;
}

export interface ContactCustomFieldCreateWithoutContactCustomValuesInput {
  id?: Maybe<Int>;
  fieldName: String;
  label: String;
  max?: Maybe<String>;
  min?: Maybe<String>;
  options?: Maybe<Json>;
  org: OrgCreateOneWithoutContactCustomFieldsInput;
  placeholder?: Maybe<String>;
  required: Boolean;
  tag: String;
  type?: Maybe<String>;
}

export interface OrgCreateOneWithoutContactCustomFieldsInput {
  create?: Maybe<OrgCreateWithoutContactCustomFieldsInput>;
  connect?: Maybe<OrgWhereUniqueInput>;
}

export interface OrgCreateWithoutContactCustomFieldsInput {
  id?: Maybe<Int>;
  accountCustomFields?: Maybe<AccountCustomFieldCreateManyWithoutOrgInput>;
  accounts?: Maybe<AccountCreateManyWithoutOrgInput>;
  contactCustomValues?: Maybe<ContactCustomValueCreateManyWithoutOrgInput>;
  contacts?: Maybe<ContactCreateManyWithoutOrgInput>;
  name: String;
  phone: String;
  primaryEmail: String;
}

export interface AccountCustomFieldCreateManyWithoutOrgInput {
  create?: Maybe<
    | AccountCustomFieldCreateWithoutOrgInput[]
    | AccountCustomFieldCreateWithoutOrgInput
  >;
  connect?: Maybe<
    AccountCustomFieldWhereUniqueInput[] | AccountCustomFieldWhereUniqueInput
  >;
}

export interface AccountCustomFieldCreateWithoutOrgInput {
  id?: Maybe<Int>;
  accountCustomValues?: Maybe<
    AccountCustomValueCreateManyWithoutAccountCustomFieldInput
  >;
  fieldName: String;
  label: String;
  max?: Maybe<String>;
  min?: Maybe<String>;
  options?: Maybe<Json>;
  placeholder?: Maybe<String>;
  required: Boolean;
  tag: String;
  type?: Maybe<String>;
}

export interface AccountCustomValueCreateManyWithoutAccountCustomFieldInput {
  create?: Maybe<
    | AccountCustomValueCreateWithoutAccountCustomFieldInput[]
    | AccountCustomValueCreateWithoutAccountCustomFieldInput
  >;
  connect?: Maybe<
    AccountCustomValueWhereUniqueInput[] | AccountCustomValueWhereUniqueInput
  >;
}

export interface AccountCustomValueCreateWithoutAccountCustomFieldInput {
  id?: Maybe<Int>;
  account: AccountCreateOneWithoutAccountCustomValuesInput;
  value: String;
}

export interface AccountCreateOneWithoutAccountCustomValuesInput {
  create?: Maybe<AccountCreateWithoutAccountCustomValuesInput>;
  connect?: Maybe<AccountWhereUniqueInput>;
}

export interface AccountCreateWithoutAccountCustomValuesInput {
  id?: Maybe<Int>;
  city: String;
  name: String;
  org: OrgCreateOneWithoutAccountsInput;
  primaryContact: ContactCreateOneWithoutAccountsInput;
  primaryEmail: String;
  primaryPhone: String;
  state: String;
  streetAddress: String;
  zip: String;
}

export interface OrgCreateOneWithoutAccountsInput {
  create?: Maybe<OrgCreateWithoutAccountsInput>;
  connect?: Maybe<OrgWhereUniqueInput>;
}

export interface OrgCreateWithoutAccountsInput {
  id?: Maybe<Int>;
  accountCustomFields?: Maybe<AccountCustomFieldCreateManyWithoutOrgInput>;
  contactCustomFields?: Maybe<ContactCustomFieldCreateManyWithoutOrgInput>;
  contactCustomValues?: Maybe<ContactCustomValueCreateManyWithoutOrgInput>;
  contacts?: Maybe<ContactCreateManyWithoutOrgInput>;
  name: String;
  phone: String;
  primaryEmail: String;
}

export interface ContactCustomFieldCreateManyWithoutOrgInput {
  create?: Maybe<
    | ContactCustomFieldCreateWithoutOrgInput[]
    | ContactCustomFieldCreateWithoutOrgInput
  >;
  connect?: Maybe<
    ContactCustomFieldWhereUniqueInput[] | ContactCustomFieldWhereUniqueInput
  >;
}

export interface ContactCustomFieldCreateWithoutOrgInput {
  id?: Maybe<Int>;
  contactCustomValues?: Maybe<
    ContactCustomValueCreateManyWithoutContactCustomFieldInput
  >;
  fieldName: String;
  label: String;
  max?: Maybe<String>;
  min?: Maybe<String>;
  options?: Maybe<Json>;
  placeholder?: Maybe<String>;
  required: Boolean;
  tag: String;
  type?: Maybe<String>;
}

export interface ContactCustomValueCreateManyWithoutContactCustomFieldInput {
  create?: Maybe<
    | ContactCustomValueCreateWithoutContactCustomFieldInput[]
    | ContactCustomValueCreateWithoutContactCustomFieldInput
  >;
  connect?: Maybe<
    ContactCustomValueWhereUniqueInput[] | ContactCustomValueWhereUniqueInput
  >;
}

export interface ContactCustomValueCreateWithoutContactCustomFieldInput {
  id?: Maybe<Int>;
  contact: ContactCreateOneWithoutContactCustomValuesInput;
  org: OrgCreateOneWithoutContactCustomValuesInput;
  value: String;
}

export interface ContactCreateOneWithoutContactCustomValuesInput {
  create?: Maybe<ContactCreateWithoutContactCustomValuesInput>;
  connect?: Maybe<ContactWhereUniqueInput>;
}

export interface ContactCreateWithoutContactCustomValuesInput {
  id?: Maybe<Int>;
  accounts?: Maybe<AccountCreateManyWithoutPrimaryContactInput>;
  city?: Maybe<String>;
  email?: Maybe<String>;
  first: String;
  last: String;
  middle?: Maybe<String>;
  org: OrgCreateOneWithoutContactsInput;
  phone?: Maybe<String>;
  state: String;
  streetAddress?: Maybe<String>;
  users?: Maybe<UserCreateManyWithoutContactInput>;
  zip?: Maybe<String>;
}

export interface AccountCreateManyWithoutPrimaryContactInput {
  create?: Maybe<
    | AccountCreateWithoutPrimaryContactInput[]
    | AccountCreateWithoutPrimaryContactInput
  >;
  connect?: Maybe<AccountWhereUniqueInput[] | AccountWhereUniqueInput>;
}

export interface AccountCreateWithoutPrimaryContactInput {
  id?: Maybe<Int>;
  accountCustomValues?: Maybe<AccountCustomValueCreateManyWithoutAccountInput>;
  city: String;
  name: String;
  org: OrgCreateOneWithoutAccountsInput;
  primaryEmail: String;
  primaryPhone: String;
  state: String;
  streetAddress: String;
  zip: String;
}

export interface OrgCreateOneWithoutContactsInput {
  create?: Maybe<OrgCreateWithoutContactsInput>;
  connect?: Maybe<OrgWhereUniqueInput>;
}

export interface OrgCreateWithoutContactsInput {
  id?: Maybe<Int>;
  accountCustomFields?: Maybe<AccountCustomFieldCreateManyWithoutOrgInput>;
  accounts?: Maybe<AccountCreateManyWithoutOrgInput>;
  contactCustomFields?: Maybe<ContactCustomFieldCreateManyWithoutOrgInput>;
  contactCustomValues?: Maybe<ContactCustomValueCreateManyWithoutOrgInput>;
  name: String;
  phone: String;
  primaryEmail: String;
}

export interface ContactCustomValueCreateManyWithoutOrgInput {
  create?: Maybe<
    | ContactCustomValueCreateWithoutOrgInput[]
    | ContactCustomValueCreateWithoutOrgInput
  >;
  connect?: Maybe<
    ContactCustomValueWhereUniqueInput[] | ContactCustomValueWhereUniqueInput
  >;
}

export interface ContactCustomValueCreateWithoutOrgInput {
  id?: Maybe<Int>;
  contact: ContactCreateOneWithoutContactCustomValuesInput;
  contactCustomField: ContactCustomFieldCreateOneWithoutContactCustomValuesInput;
  value: String;
}

export interface UserCreateManyWithoutContactInput {
  create?: Maybe<
    UserCreateWithoutContactInput[] | UserCreateWithoutContactInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutContactInput {
  id?: Maybe<Int>;
  email: String;
  emailVerifiedAt?: Maybe<DateTimeInput>;
  orgId: Int;
  password: String;
  rememberToken?: Maybe<String>;
  role?: Maybe<UsersRoleEnum>;
}

export interface OrgCreateOneWithoutContactCustomValuesInput {
  create?: Maybe<OrgCreateWithoutContactCustomValuesInput>;
  connect?: Maybe<OrgWhereUniqueInput>;
}

export interface OrgCreateWithoutContactCustomValuesInput {
  id?: Maybe<Int>;
  accountCustomFields?: Maybe<AccountCustomFieldCreateManyWithoutOrgInput>;
  accounts?: Maybe<AccountCreateManyWithoutOrgInput>;
  contactCustomFields?: Maybe<ContactCustomFieldCreateManyWithoutOrgInput>;
  contacts?: Maybe<ContactCreateManyWithoutOrgInput>;
  name: String;
  phone: String;
  primaryEmail: String;
}

export interface ContactCreateManyWithoutOrgInput {
  create?: Maybe<ContactCreateWithoutOrgInput[] | ContactCreateWithoutOrgInput>;
  connect?: Maybe<ContactWhereUniqueInput[] | ContactWhereUniqueInput>;
}

export interface ContactCreateWithoutOrgInput {
  id?: Maybe<Int>;
  accounts?: Maybe<AccountCreateManyWithoutPrimaryContactInput>;
  city?: Maybe<String>;
  contactCustomValues?: Maybe<ContactCustomValueCreateManyWithoutContactInput>;
  email?: Maybe<String>;
  first: String;
  last: String;
  middle?: Maybe<String>;
  phone?: Maybe<String>;
  state: String;
  streetAddress?: Maybe<String>;
  users?: Maybe<UserCreateManyWithoutContactInput>;
  zip?: Maybe<String>;
}

export interface AccountUpdateInput {
  accountCustomValues?: Maybe<AccountCustomValueUpdateManyWithoutAccountInput>;
  city?: Maybe<String>;
  name?: Maybe<String>;
  org?: Maybe<OrgUpdateOneRequiredWithoutAccountsInput>;
  primaryContact?: Maybe<ContactUpdateOneRequiredWithoutAccountsInput>;
  primaryEmail?: Maybe<String>;
  primaryPhone?: Maybe<String>;
  state?: Maybe<String>;
  streetAddress?: Maybe<String>;
  zip?: Maybe<String>;
}

export interface AccountCustomValueUpdateManyWithoutAccountInput {
  create?: Maybe<
    | AccountCustomValueCreateWithoutAccountInput[]
    | AccountCustomValueCreateWithoutAccountInput
  >;
  delete?: Maybe<
    AccountCustomValueWhereUniqueInput[] | AccountCustomValueWhereUniqueInput
  >;
  connect?: Maybe<
    AccountCustomValueWhereUniqueInput[] | AccountCustomValueWhereUniqueInput
  >;
  set?: Maybe<
    AccountCustomValueWhereUniqueInput[] | AccountCustomValueWhereUniqueInput
  >;
  disconnect?: Maybe<
    AccountCustomValueWhereUniqueInput[] | AccountCustomValueWhereUniqueInput
  >;
  update?: Maybe<
    | AccountCustomValueUpdateWithWhereUniqueWithoutAccountInput[]
    | AccountCustomValueUpdateWithWhereUniqueWithoutAccountInput
  >;
  upsert?: Maybe<
    | AccountCustomValueUpsertWithWhereUniqueWithoutAccountInput[]
    | AccountCustomValueUpsertWithWhereUniqueWithoutAccountInput
  >;
  deleteMany?: Maybe<
    AccountCustomValueScalarWhereInput[] | AccountCustomValueScalarWhereInput
  >;
  updateMany?: Maybe<
    | AccountCustomValueUpdateManyWithWhereNestedInput[]
    | AccountCustomValueUpdateManyWithWhereNestedInput
  >;
}

export interface AccountCustomValueUpdateWithWhereUniqueWithoutAccountInput {
  where: AccountCustomValueWhereUniqueInput;
  data: AccountCustomValueUpdateWithoutAccountDataInput;
}

export interface AccountCustomValueUpdateWithoutAccountDataInput {
  accountCustomField?: Maybe<
    AccountCustomFieldUpdateOneRequiredWithoutAccountCustomValuesInput
  >;
  value?: Maybe<String>;
}

export interface AccountCustomFieldUpdateOneRequiredWithoutAccountCustomValuesInput {
  create?: Maybe<AccountCustomFieldCreateWithoutAccountCustomValuesInput>;
  update?: Maybe<AccountCustomFieldUpdateWithoutAccountCustomValuesDataInput>;
  upsert?: Maybe<AccountCustomFieldUpsertWithoutAccountCustomValuesInput>;
  connect?: Maybe<AccountCustomFieldWhereUniqueInput>;
}

export interface AccountCustomFieldUpdateWithoutAccountCustomValuesDataInput {
  fieldName?: Maybe<String>;
  label?: Maybe<String>;
  max?: Maybe<String>;
  min?: Maybe<String>;
  options?: Maybe<Json>;
  org?: Maybe<OrgUpdateOneRequiredWithoutAccountCustomFieldsInput>;
  placeholder?: Maybe<String>;
  required?: Maybe<Boolean>;
  tag?: Maybe<String>;
  type?: Maybe<String>;
}

export interface OrgUpdateOneRequiredWithoutAccountCustomFieldsInput {
  create?: Maybe<OrgCreateWithoutAccountCustomFieldsInput>;
  update?: Maybe<OrgUpdateWithoutAccountCustomFieldsDataInput>;
  upsert?: Maybe<OrgUpsertWithoutAccountCustomFieldsInput>;
  connect?: Maybe<OrgWhereUniqueInput>;
}

export interface OrgUpdateWithoutAccountCustomFieldsDataInput {
  accounts?: Maybe<AccountUpdateManyWithoutOrgInput>;
  contactCustomFields?: Maybe<ContactCustomFieldUpdateManyWithoutOrgInput>;
  contactCustomValues?: Maybe<ContactCustomValueUpdateManyWithoutOrgInput>;
  contacts?: Maybe<ContactUpdateManyWithoutOrgInput>;
  name?: Maybe<String>;
  phone?: Maybe<String>;
  primaryEmail?: Maybe<String>;
}

export interface AccountUpdateManyWithoutOrgInput {
  create?: Maybe<AccountCreateWithoutOrgInput[] | AccountCreateWithoutOrgInput>;
  delete?: Maybe<AccountWhereUniqueInput[] | AccountWhereUniqueInput>;
  connect?: Maybe<AccountWhereUniqueInput[] | AccountWhereUniqueInput>;
  set?: Maybe<AccountWhereUniqueInput[] | AccountWhereUniqueInput>;
  disconnect?: Maybe<AccountWhereUniqueInput[] | AccountWhereUniqueInput>;
  update?: Maybe<
    | AccountUpdateWithWhereUniqueWithoutOrgInput[]
    | AccountUpdateWithWhereUniqueWithoutOrgInput
  >;
  upsert?: Maybe<
    | AccountUpsertWithWhereUniqueWithoutOrgInput[]
    | AccountUpsertWithWhereUniqueWithoutOrgInput
  >;
  deleteMany?: Maybe<AccountScalarWhereInput[] | AccountScalarWhereInput>;
  updateMany?: Maybe<
    | AccountUpdateManyWithWhereNestedInput[]
    | AccountUpdateManyWithWhereNestedInput
  >;
}

export interface AccountUpdateWithWhereUniqueWithoutOrgInput {
  where: AccountWhereUniqueInput;
  data: AccountUpdateWithoutOrgDataInput;
}

export interface AccountUpdateWithoutOrgDataInput {
  accountCustomValues?: Maybe<AccountCustomValueUpdateManyWithoutAccountInput>;
  city?: Maybe<String>;
  name?: Maybe<String>;
  primaryContact?: Maybe<ContactUpdateOneRequiredWithoutAccountsInput>;
  primaryEmail?: Maybe<String>;
  primaryPhone?: Maybe<String>;
  state?: Maybe<String>;
  streetAddress?: Maybe<String>;
  zip?: Maybe<String>;
}

export interface ContactUpdateOneRequiredWithoutAccountsInput {
  create?: Maybe<ContactCreateWithoutAccountsInput>;
  update?: Maybe<ContactUpdateWithoutAccountsDataInput>;
  upsert?: Maybe<ContactUpsertWithoutAccountsInput>;
  connect?: Maybe<ContactWhereUniqueInput>;
}

export interface ContactUpdateWithoutAccountsDataInput {
  city?: Maybe<String>;
  contactCustomValues?: Maybe<ContactCustomValueUpdateManyWithoutContactInput>;
  email?: Maybe<String>;
  first?: Maybe<String>;
  last?: Maybe<String>;
  middle?: Maybe<String>;
  org?: Maybe<OrgUpdateOneRequiredWithoutContactsInput>;
  phone?: Maybe<String>;
  state?: Maybe<String>;
  streetAddress?: Maybe<String>;
  users?: Maybe<UserUpdateManyWithoutContactInput>;
  zip?: Maybe<String>;
}

export interface ContactCustomValueUpdateManyWithoutContactInput {
  create?: Maybe<
    | ContactCustomValueCreateWithoutContactInput[]
    | ContactCustomValueCreateWithoutContactInput
  >;
  delete?: Maybe<
    ContactCustomValueWhereUniqueInput[] | ContactCustomValueWhereUniqueInput
  >;
  connect?: Maybe<
    ContactCustomValueWhereUniqueInput[] | ContactCustomValueWhereUniqueInput
  >;
  set?: Maybe<
    ContactCustomValueWhereUniqueInput[] | ContactCustomValueWhereUniqueInput
  >;
  disconnect?: Maybe<
    ContactCustomValueWhereUniqueInput[] | ContactCustomValueWhereUniqueInput
  >;
  update?: Maybe<
    | ContactCustomValueUpdateWithWhereUniqueWithoutContactInput[]
    | ContactCustomValueUpdateWithWhereUniqueWithoutContactInput
  >;
  upsert?: Maybe<
    | ContactCustomValueUpsertWithWhereUniqueWithoutContactInput[]
    | ContactCustomValueUpsertWithWhereUniqueWithoutContactInput
  >;
  deleteMany?: Maybe<
    ContactCustomValueScalarWhereInput[] | ContactCustomValueScalarWhereInput
  >;
  updateMany?: Maybe<
    | ContactCustomValueUpdateManyWithWhereNestedInput[]
    | ContactCustomValueUpdateManyWithWhereNestedInput
  >;
}

export interface ContactCustomValueUpdateWithWhereUniqueWithoutContactInput {
  where: ContactCustomValueWhereUniqueInput;
  data: ContactCustomValueUpdateWithoutContactDataInput;
}

export interface ContactCustomValueUpdateWithoutContactDataInput {
  contactCustomField?: Maybe<
    ContactCustomFieldUpdateOneRequiredWithoutContactCustomValuesInput
  >;
  org?: Maybe<OrgUpdateOneRequiredWithoutContactCustomValuesInput>;
  value?: Maybe<String>;
}

export interface ContactCustomFieldUpdateOneRequiredWithoutContactCustomValuesInput {
  create?: Maybe<ContactCustomFieldCreateWithoutContactCustomValuesInput>;
  update?: Maybe<ContactCustomFieldUpdateWithoutContactCustomValuesDataInput>;
  upsert?: Maybe<ContactCustomFieldUpsertWithoutContactCustomValuesInput>;
  connect?: Maybe<ContactCustomFieldWhereUniqueInput>;
}

export interface ContactCustomFieldUpdateWithoutContactCustomValuesDataInput {
  fieldName?: Maybe<String>;
  label?: Maybe<String>;
  max?: Maybe<String>;
  min?: Maybe<String>;
  options?: Maybe<Json>;
  org?: Maybe<OrgUpdateOneRequiredWithoutContactCustomFieldsInput>;
  placeholder?: Maybe<String>;
  required?: Maybe<Boolean>;
  tag?: Maybe<String>;
  type?: Maybe<String>;
}

export interface OrgUpdateOneRequiredWithoutContactCustomFieldsInput {
  create?: Maybe<OrgCreateWithoutContactCustomFieldsInput>;
  update?: Maybe<OrgUpdateWithoutContactCustomFieldsDataInput>;
  upsert?: Maybe<OrgUpsertWithoutContactCustomFieldsInput>;
  connect?: Maybe<OrgWhereUniqueInput>;
}

export interface OrgUpdateWithoutContactCustomFieldsDataInput {
  accountCustomFields?: Maybe<AccountCustomFieldUpdateManyWithoutOrgInput>;
  accounts?: Maybe<AccountUpdateManyWithoutOrgInput>;
  contactCustomValues?: Maybe<ContactCustomValueUpdateManyWithoutOrgInput>;
  contacts?: Maybe<ContactUpdateManyWithoutOrgInput>;
  name?: Maybe<String>;
  phone?: Maybe<String>;
  primaryEmail?: Maybe<String>;
}

export interface AccountCustomFieldUpdateManyWithoutOrgInput {
  create?: Maybe<
    | AccountCustomFieldCreateWithoutOrgInput[]
    | AccountCustomFieldCreateWithoutOrgInput
  >;
  delete?: Maybe<
    AccountCustomFieldWhereUniqueInput[] | AccountCustomFieldWhereUniqueInput
  >;
  connect?: Maybe<
    AccountCustomFieldWhereUniqueInput[] | AccountCustomFieldWhereUniqueInput
  >;
  set?: Maybe<
    AccountCustomFieldWhereUniqueInput[] | AccountCustomFieldWhereUniqueInput
  >;
  disconnect?: Maybe<
    AccountCustomFieldWhereUniqueInput[] | AccountCustomFieldWhereUniqueInput
  >;
  update?: Maybe<
    | AccountCustomFieldUpdateWithWhereUniqueWithoutOrgInput[]
    | AccountCustomFieldUpdateWithWhereUniqueWithoutOrgInput
  >;
  upsert?: Maybe<
    | AccountCustomFieldUpsertWithWhereUniqueWithoutOrgInput[]
    | AccountCustomFieldUpsertWithWhereUniqueWithoutOrgInput
  >;
  deleteMany?: Maybe<
    AccountCustomFieldScalarWhereInput[] | AccountCustomFieldScalarWhereInput
  >;
  updateMany?: Maybe<
    | AccountCustomFieldUpdateManyWithWhereNestedInput[]
    | AccountCustomFieldUpdateManyWithWhereNestedInput
  >;
}

export interface AccountCustomFieldUpdateWithWhereUniqueWithoutOrgInput {
  where: AccountCustomFieldWhereUniqueInput;
  data: AccountCustomFieldUpdateWithoutOrgDataInput;
}

export interface AccountCustomFieldUpdateWithoutOrgDataInput {
  accountCustomValues?: Maybe<
    AccountCustomValueUpdateManyWithoutAccountCustomFieldInput
  >;
  fieldName?: Maybe<String>;
  label?: Maybe<String>;
  max?: Maybe<String>;
  min?: Maybe<String>;
  options?: Maybe<Json>;
  placeholder?: Maybe<String>;
  required?: Maybe<Boolean>;
  tag?: Maybe<String>;
  type?: Maybe<String>;
}

export interface AccountCustomValueUpdateManyWithoutAccountCustomFieldInput {
  create?: Maybe<
    | AccountCustomValueCreateWithoutAccountCustomFieldInput[]
    | AccountCustomValueCreateWithoutAccountCustomFieldInput
  >;
  delete?: Maybe<
    AccountCustomValueWhereUniqueInput[] | AccountCustomValueWhereUniqueInput
  >;
  connect?: Maybe<
    AccountCustomValueWhereUniqueInput[] | AccountCustomValueWhereUniqueInput
  >;
  set?: Maybe<
    AccountCustomValueWhereUniqueInput[] | AccountCustomValueWhereUniqueInput
  >;
  disconnect?: Maybe<
    AccountCustomValueWhereUniqueInput[] | AccountCustomValueWhereUniqueInput
  >;
  update?: Maybe<
    | AccountCustomValueUpdateWithWhereUniqueWithoutAccountCustomFieldInput[]
    | AccountCustomValueUpdateWithWhereUniqueWithoutAccountCustomFieldInput
  >;
  upsert?: Maybe<
    | AccountCustomValueUpsertWithWhereUniqueWithoutAccountCustomFieldInput[]
    | AccountCustomValueUpsertWithWhereUniqueWithoutAccountCustomFieldInput
  >;
  deleteMany?: Maybe<
    AccountCustomValueScalarWhereInput[] | AccountCustomValueScalarWhereInput
  >;
  updateMany?: Maybe<
    | AccountCustomValueUpdateManyWithWhereNestedInput[]
    | AccountCustomValueUpdateManyWithWhereNestedInput
  >;
}

export interface AccountCustomValueUpdateWithWhereUniqueWithoutAccountCustomFieldInput {
  where: AccountCustomValueWhereUniqueInput;
  data: AccountCustomValueUpdateWithoutAccountCustomFieldDataInput;
}

export interface AccountCustomValueUpdateWithoutAccountCustomFieldDataInput {
  account?: Maybe<AccountUpdateOneRequiredWithoutAccountCustomValuesInput>;
  value?: Maybe<String>;
}

export interface AccountUpdateOneRequiredWithoutAccountCustomValuesInput {
  create?: Maybe<AccountCreateWithoutAccountCustomValuesInput>;
  update?: Maybe<AccountUpdateWithoutAccountCustomValuesDataInput>;
  upsert?: Maybe<AccountUpsertWithoutAccountCustomValuesInput>;
  connect?: Maybe<AccountWhereUniqueInput>;
}

export interface AccountUpdateWithoutAccountCustomValuesDataInput {
  city?: Maybe<String>;
  name?: Maybe<String>;
  org?: Maybe<OrgUpdateOneRequiredWithoutAccountsInput>;
  primaryContact?: Maybe<ContactUpdateOneRequiredWithoutAccountsInput>;
  primaryEmail?: Maybe<String>;
  primaryPhone?: Maybe<String>;
  state?: Maybe<String>;
  streetAddress?: Maybe<String>;
  zip?: Maybe<String>;
}

export interface OrgUpdateOneRequiredWithoutAccountsInput {
  create?: Maybe<OrgCreateWithoutAccountsInput>;
  update?: Maybe<OrgUpdateWithoutAccountsDataInput>;
  upsert?: Maybe<OrgUpsertWithoutAccountsInput>;
  connect?: Maybe<OrgWhereUniqueInput>;
}

export interface OrgUpdateWithoutAccountsDataInput {
  accountCustomFields?: Maybe<AccountCustomFieldUpdateManyWithoutOrgInput>;
  contactCustomFields?: Maybe<ContactCustomFieldUpdateManyWithoutOrgInput>;
  contactCustomValues?: Maybe<ContactCustomValueUpdateManyWithoutOrgInput>;
  contacts?: Maybe<ContactUpdateManyWithoutOrgInput>;
  name?: Maybe<String>;
  phone?: Maybe<String>;
  primaryEmail?: Maybe<String>;
}

export interface ContactCustomFieldUpdateManyWithoutOrgInput {
  create?: Maybe<
    | ContactCustomFieldCreateWithoutOrgInput[]
    | ContactCustomFieldCreateWithoutOrgInput
  >;
  delete?: Maybe<
    ContactCustomFieldWhereUniqueInput[] | ContactCustomFieldWhereUniqueInput
  >;
  connect?: Maybe<
    ContactCustomFieldWhereUniqueInput[] | ContactCustomFieldWhereUniqueInput
  >;
  set?: Maybe<
    ContactCustomFieldWhereUniqueInput[] | ContactCustomFieldWhereUniqueInput
  >;
  disconnect?: Maybe<
    ContactCustomFieldWhereUniqueInput[] | ContactCustomFieldWhereUniqueInput
  >;
  update?: Maybe<
    | ContactCustomFieldUpdateWithWhereUniqueWithoutOrgInput[]
    | ContactCustomFieldUpdateWithWhereUniqueWithoutOrgInput
  >;
  upsert?: Maybe<
    | ContactCustomFieldUpsertWithWhereUniqueWithoutOrgInput[]
    | ContactCustomFieldUpsertWithWhereUniqueWithoutOrgInput
  >;
  deleteMany?: Maybe<
    ContactCustomFieldScalarWhereInput[] | ContactCustomFieldScalarWhereInput
  >;
  updateMany?: Maybe<
    | ContactCustomFieldUpdateManyWithWhereNestedInput[]
    | ContactCustomFieldUpdateManyWithWhereNestedInput
  >;
}

export interface ContactCustomFieldUpdateWithWhereUniqueWithoutOrgInput {
  where: ContactCustomFieldWhereUniqueInput;
  data: ContactCustomFieldUpdateWithoutOrgDataInput;
}

export interface ContactCustomFieldUpdateWithoutOrgDataInput {
  contactCustomValues?: Maybe<
    ContactCustomValueUpdateManyWithoutContactCustomFieldInput
  >;
  fieldName?: Maybe<String>;
  label?: Maybe<String>;
  max?: Maybe<String>;
  min?: Maybe<String>;
  options?: Maybe<Json>;
  placeholder?: Maybe<String>;
  required?: Maybe<Boolean>;
  tag?: Maybe<String>;
  type?: Maybe<String>;
}

export interface ContactCustomValueUpdateManyWithoutContactCustomFieldInput {
  create?: Maybe<
    | ContactCustomValueCreateWithoutContactCustomFieldInput[]
    | ContactCustomValueCreateWithoutContactCustomFieldInput
  >;
  delete?: Maybe<
    ContactCustomValueWhereUniqueInput[] | ContactCustomValueWhereUniqueInput
  >;
  connect?: Maybe<
    ContactCustomValueWhereUniqueInput[] | ContactCustomValueWhereUniqueInput
  >;
  set?: Maybe<
    ContactCustomValueWhereUniqueInput[] | ContactCustomValueWhereUniqueInput
  >;
  disconnect?: Maybe<
    ContactCustomValueWhereUniqueInput[] | ContactCustomValueWhereUniqueInput
  >;
  update?: Maybe<
    | ContactCustomValueUpdateWithWhereUniqueWithoutContactCustomFieldInput[]
    | ContactCustomValueUpdateWithWhereUniqueWithoutContactCustomFieldInput
  >;
  upsert?: Maybe<
    | ContactCustomValueUpsertWithWhereUniqueWithoutContactCustomFieldInput[]
    | ContactCustomValueUpsertWithWhereUniqueWithoutContactCustomFieldInput
  >;
  deleteMany?: Maybe<
    ContactCustomValueScalarWhereInput[] | ContactCustomValueScalarWhereInput
  >;
  updateMany?: Maybe<
    | ContactCustomValueUpdateManyWithWhereNestedInput[]
    | ContactCustomValueUpdateManyWithWhereNestedInput
  >;
}

export interface ContactCustomValueUpdateWithWhereUniqueWithoutContactCustomFieldInput {
  where: ContactCustomValueWhereUniqueInput;
  data: ContactCustomValueUpdateWithoutContactCustomFieldDataInput;
}

export interface ContactCustomValueUpdateWithoutContactCustomFieldDataInput {
  contact?: Maybe<ContactUpdateOneRequiredWithoutContactCustomValuesInput>;
  org?: Maybe<OrgUpdateOneRequiredWithoutContactCustomValuesInput>;
  value?: Maybe<String>;
}

export interface ContactUpdateOneRequiredWithoutContactCustomValuesInput {
  create?: Maybe<ContactCreateWithoutContactCustomValuesInput>;
  update?: Maybe<ContactUpdateWithoutContactCustomValuesDataInput>;
  upsert?: Maybe<ContactUpsertWithoutContactCustomValuesInput>;
  connect?: Maybe<ContactWhereUniqueInput>;
}

export interface ContactUpdateWithoutContactCustomValuesDataInput {
  accounts?: Maybe<AccountUpdateManyWithoutPrimaryContactInput>;
  city?: Maybe<String>;
  email?: Maybe<String>;
  first?: Maybe<String>;
  last?: Maybe<String>;
  middle?: Maybe<String>;
  org?: Maybe<OrgUpdateOneRequiredWithoutContactsInput>;
  phone?: Maybe<String>;
  state?: Maybe<String>;
  streetAddress?: Maybe<String>;
  users?: Maybe<UserUpdateManyWithoutContactInput>;
  zip?: Maybe<String>;
}

export interface AccountUpdateManyWithoutPrimaryContactInput {
  create?: Maybe<
    | AccountCreateWithoutPrimaryContactInput[]
    | AccountCreateWithoutPrimaryContactInput
  >;
  delete?: Maybe<AccountWhereUniqueInput[] | AccountWhereUniqueInput>;
  connect?: Maybe<AccountWhereUniqueInput[] | AccountWhereUniqueInput>;
  set?: Maybe<AccountWhereUniqueInput[] | AccountWhereUniqueInput>;
  disconnect?: Maybe<AccountWhereUniqueInput[] | AccountWhereUniqueInput>;
  update?: Maybe<
    | AccountUpdateWithWhereUniqueWithoutPrimaryContactInput[]
    | AccountUpdateWithWhereUniqueWithoutPrimaryContactInput
  >;
  upsert?: Maybe<
    | AccountUpsertWithWhereUniqueWithoutPrimaryContactInput[]
    | AccountUpsertWithWhereUniqueWithoutPrimaryContactInput
  >;
  deleteMany?: Maybe<AccountScalarWhereInput[] | AccountScalarWhereInput>;
  updateMany?: Maybe<
    | AccountUpdateManyWithWhereNestedInput[]
    | AccountUpdateManyWithWhereNestedInput
  >;
}

export interface AccountUpdateWithWhereUniqueWithoutPrimaryContactInput {
  where: AccountWhereUniqueInput;
  data: AccountUpdateWithoutPrimaryContactDataInput;
}

export interface AccountUpdateWithoutPrimaryContactDataInput {
  accountCustomValues?: Maybe<AccountCustomValueUpdateManyWithoutAccountInput>;
  city?: Maybe<String>;
  name?: Maybe<String>;
  org?: Maybe<OrgUpdateOneRequiredWithoutAccountsInput>;
  primaryEmail?: Maybe<String>;
  primaryPhone?: Maybe<String>;
  state?: Maybe<String>;
  streetAddress?: Maybe<String>;
  zip?: Maybe<String>;
}

export interface AccountUpsertWithWhereUniqueWithoutPrimaryContactInput {
  where: AccountWhereUniqueInput;
  update: AccountUpdateWithoutPrimaryContactDataInput;
  create: AccountCreateWithoutPrimaryContactInput;
}

export interface AccountScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  primaryEmail?: Maybe<String>;
  primaryEmail_not?: Maybe<String>;
  primaryEmail_in?: Maybe<String[] | String>;
  primaryEmail_not_in?: Maybe<String[] | String>;
  primaryEmail_lt?: Maybe<String>;
  primaryEmail_lte?: Maybe<String>;
  primaryEmail_gt?: Maybe<String>;
  primaryEmail_gte?: Maybe<String>;
  primaryEmail_contains?: Maybe<String>;
  primaryEmail_not_contains?: Maybe<String>;
  primaryEmail_starts_with?: Maybe<String>;
  primaryEmail_not_starts_with?: Maybe<String>;
  primaryEmail_ends_with?: Maybe<String>;
  primaryEmail_not_ends_with?: Maybe<String>;
  primaryPhone?: Maybe<String>;
  primaryPhone_not?: Maybe<String>;
  primaryPhone_in?: Maybe<String[] | String>;
  primaryPhone_not_in?: Maybe<String[] | String>;
  primaryPhone_lt?: Maybe<String>;
  primaryPhone_lte?: Maybe<String>;
  primaryPhone_gt?: Maybe<String>;
  primaryPhone_gte?: Maybe<String>;
  primaryPhone_contains?: Maybe<String>;
  primaryPhone_not_contains?: Maybe<String>;
  primaryPhone_starts_with?: Maybe<String>;
  primaryPhone_not_starts_with?: Maybe<String>;
  primaryPhone_ends_with?: Maybe<String>;
  primaryPhone_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  streetAddress?: Maybe<String>;
  streetAddress_not?: Maybe<String>;
  streetAddress_in?: Maybe<String[] | String>;
  streetAddress_not_in?: Maybe<String[] | String>;
  streetAddress_lt?: Maybe<String>;
  streetAddress_lte?: Maybe<String>;
  streetAddress_gt?: Maybe<String>;
  streetAddress_gte?: Maybe<String>;
  streetAddress_contains?: Maybe<String>;
  streetAddress_not_contains?: Maybe<String>;
  streetAddress_starts_with?: Maybe<String>;
  streetAddress_not_starts_with?: Maybe<String>;
  streetAddress_ends_with?: Maybe<String>;
  streetAddress_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  zip?: Maybe<String>;
  zip_not?: Maybe<String>;
  zip_in?: Maybe<String[] | String>;
  zip_not_in?: Maybe<String[] | String>;
  zip_lt?: Maybe<String>;
  zip_lte?: Maybe<String>;
  zip_gt?: Maybe<String>;
  zip_gte?: Maybe<String>;
  zip_contains?: Maybe<String>;
  zip_not_contains?: Maybe<String>;
  zip_starts_with?: Maybe<String>;
  zip_not_starts_with?: Maybe<String>;
  zip_ends_with?: Maybe<String>;
  zip_not_ends_with?: Maybe<String>;
  AND?: Maybe<AccountScalarWhereInput[] | AccountScalarWhereInput>;
  OR?: Maybe<AccountScalarWhereInput[] | AccountScalarWhereInput>;
  NOT?: Maybe<AccountScalarWhereInput[] | AccountScalarWhereInput>;
}

export interface AccountUpdateManyWithWhereNestedInput {
  where: AccountScalarWhereInput;
  data: AccountUpdateManyDataInput;
}

export interface AccountUpdateManyDataInput {
  city?: Maybe<String>;
  name?: Maybe<String>;
  primaryEmail?: Maybe<String>;
  primaryPhone?: Maybe<String>;
  state?: Maybe<String>;
  streetAddress?: Maybe<String>;
  zip?: Maybe<String>;
}

export interface OrgUpdateOneRequiredWithoutContactsInput {
  create?: Maybe<OrgCreateWithoutContactsInput>;
  update?: Maybe<OrgUpdateWithoutContactsDataInput>;
  upsert?: Maybe<OrgUpsertWithoutContactsInput>;
  connect?: Maybe<OrgWhereUniqueInput>;
}

export interface OrgUpdateWithoutContactsDataInput {
  accountCustomFields?: Maybe<AccountCustomFieldUpdateManyWithoutOrgInput>;
  accounts?: Maybe<AccountUpdateManyWithoutOrgInput>;
  contactCustomFields?: Maybe<ContactCustomFieldUpdateManyWithoutOrgInput>;
  contactCustomValues?: Maybe<ContactCustomValueUpdateManyWithoutOrgInput>;
  name?: Maybe<String>;
  phone?: Maybe<String>;
  primaryEmail?: Maybe<String>;
}

export interface ContactCustomValueUpdateManyWithoutOrgInput {
  create?: Maybe<
    | ContactCustomValueCreateWithoutOrgInput[]
    | ContactCustomValueCreateWithoutOrgInput
  >;
  delete?: Maybe<
    ContactCustomValueWhereUniqueInput[] | ContactCustomValueWhereUniqueInput
  >;
  connect?: Maybe<
    ContactCustomValueWhereUniqueInput[] | ContactCustomValueWhereUniqueInput
  >;
  set?: Maybe<
    ContactCustomValueWhereUniqueInput[] | ContactCustomValueWhereUniqueInput
  >;
  disconnect?: Maybe<
    ContactCustomValueWhereUniqueInput[] | ContactCustomValueWhereUniqueInput
  >;
  update?: Maybe<
    | ContactCustomValueUpdateWithWhereUniqueWithoutOrgInput[]
    | ContactCustomValueUpdateWithWhereUniqueWithoutOrgInput
  >;
  upsert?: Maybe<
    | ContactCustomValueUpsertWithWhereUniqueWithoutOrgInput[]
    | ContactCustomValueUpsertWithWhereUniqueWithoutOrgInput
  >;
  deleteMany?: Maybe<
    ContactCustomValueScalarWhereInput[] | ContactCustomValueScalarWhereInput
  >;
  updateMany?: Maybe<
    | ContactCustomValueUpdateManyWithWhereNestedInput[]
    | ContactCustomValueUpdateManyWithWhereNestedInput
  >;
}

export interface ContactCustomValueUpdateWithWhereUniqueWithoutOrgInput {
  where: ContactCustomValueWhereUniqueInput;
  data: ContactCustomValueUpdateWithoutOrgDataInput;
}

export interface ContactCustomValueUpdateWithoutOrgDataInput {
  contact?: Maybe<ContactUpdateOneRequiredWithoutContactCustomValuesInput>;
  contactCustomField?: Maybe<
    ContactCustomFieldUpdateOneRequiredWithoutContactCustomValuesInput
  >;
  value?: Maybe<String>;
}

export interface ContactCustomValueUpsertWithWhereUniqueWithoutOrgInput {
  where: ContactCustomValueWhereUniqueInput;
  update: ContactCustomValueUpdateWithoutOrgDataInput;
  create: ContactCustomValueCreateWithoutOrgInput;
}

export interface ContactCustomValueScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    ContactCustomValueScalarWhereInput[] | ContactCustomValueScalarWhereInput
  >;
  OR?: Maybe<
    ContactCustomValueScalarWhereInput[] | ContactCustomValueScalarWhereInput
  >;
  NOT?: Maybe<
    ContactCustomValueScalarWhereInput[] | ContactCustomValueScalarWhereInput
  >;
}

export interface ContactCustomValueUpdateManyWithWhereNestedInput {
  where: ContactCustomValueScalarWhereInput;
  data: ContactCustomValueUpdateManyDataInput;
}

export interface ContactCustomValueUpdateManyDataInput {
  value?: Maybe<String>;
}

export interface OrgUpsertWithoutContactsInput {
  update: OrgUpdateWithoutContactsDataInput;
  create: OrgCreateWithoutContactsInput;
}

export interface UserUpdateManyWithoutContactInput {
  create?: Maybe<
    UserCreateWithoutContactInput[] | UserCreateWithoutContactInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutContactInput[]
    | UserUpdateWithWhereUniqueWithoutContactInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutContactInput[]
    | UserUpsertWithWhereUniqueWithoutContactInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutContactInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutContactDataInput;
}

export interface UserUpdateWithoutContactDataInput {
  email?: Maybe<String>;
  emailVerifiedAt?: Maybe<DateTimeInput>;
  orgId?: Maybe<Int>;
  password?: Maybe<String>;
  rememberToken?: Maybe<String>;
  role?: Maybe<UsersRoleEnum>;
}

export interface UserUpsertWithWhereUniqueWithoutContactInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutContactDataInput;
  create: UserCreateWithoutContactInput;
}

export interface UserScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  emailVerifiedAt?: Maybe<DateTimeInput>;
  emailVerifiedAt_not?: Maybe<DateTimeInput>;
  emailVerifiedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  emailVerifiedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  emailVerifiedAt_lt?: Maybe<DateTimeInput>;
  emailVerifiedAt_lte?: Maybe<DateTimeInput>;
  emailVerifiedAt_gt?: Maybe<DateTimeInput>;
  emailVerifiedAt_gte?: Maybe<DateTimeInput>;
  orgId?: Maybe<Int>;
  orgId_not?: Maybe<Int>;
  orgId_in?: Maybe<Int[] | Int>;
  orgId_not_in?: Maybe<Int[] | Int>;
  orgId_lt?: Maybe<Int>;
  orgId_lte?: Maybe<Int>;
  orgId_gt?: Maybe<Int>;
  orgId_gte?: Maybe<Int>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  rememberToken?: Maybe<String>;
  rememberToken_not?: Maybe<String>;
  rememberToken_in?: Maybe<String[] | String>;
  rememberToken_not_in?: Maybe<String[] | String>;
  rememberToken_lt?: Maybe<String>;
  rememberToken_lte?: Maybe<String>;
  rememberToken_gt?: Maybe<String>;
  rememberToken_gte?: Maybe<String>;
  rememberToken_contains?: Maybe<String>;
  rememberToken_not_contains?: Maybe<String>;
  rememberToken_starts_with?: Maybe<String>;
  rememberToken_not_starts_with?: Maybe<String>;
  rememberToken_ends_with?: Maybe<String>;
  rememberToken_not_ends_with?: Maybe<String>;
  role?: Maybe<UsersRoleEnum>;
  role_not?: Maybe<UsersRoleEnum>;
  role_in?: Maybe<UsersRoleEnum[] | UsersRoleEnum>;
  role_not_in?: Maybe<UsersRoleEnum[] | UsersRoleEnum>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  email?: Maybe<String>;
  emailVerifiedAt?: Maybe<DateTimeInput>;
  orgId?: Maybe<Int>;
  password?: Maybe<String>;
  rememberToken?: Maybe<String>;
  role?: Maybe<UsersRoleEnum>;
}

export interface ContactUpsertWithoutContactCustomValuesInput {
  update: ContactUpdateWithoutContactCustomValuesDataInput;
  create: ContactCreateWithoutContactCustomValuesInput;
}

export interface OrgUpdateOneRequiredWithoutContactCustomValuesInput {
  create?: Maybe<OrgCreateWithoutContactCustomValuesInput>;
  update?: Maybe<OrgUpdateWithoutContactCustomValuesDataInput>;
  upsert?: Maybe<OrgUpsertWithoutContactCustomValuesInput>;
  connect?: Maybe<OrgWhereUniqueInput>;
}

export interface OrgUpdateWithoutContactCustomValuesDataInput {
  accountCustomFields?: Maybe<AccountCustomFieldUpdateManyWithoutOrgInput>;
  accounts?: Maybe<AccountUpdateManyWithoutOrgInput>;
  contactCustomFields?: Maybe<ContactCustomFieldUpdateManyWithoutOrgInput>;
  contacts?: Maybe<ContactUpdateManyWithoutOrgInput>;
  name?: Maybe<String>;
  phone?: Maybe<String>;
  primaryEmail?: Maybe<String>;
}

export interface ContactUpdateManyWithoutOrgInput {
  create?: Maybe<ContactCreateWithoutOrgInput[] | ContactCreateWithoutOrgInput>;
  delete?: Maybe<ContactWhereUniqueInput[] | ContactWhereUniqueInput>;
  connect?: Maybe<ContactWhereUniqueInput[] | ContactWhereUniqueInput>;
  set?: Maybe<ContactWhereUniqueInput[] | ContactWhereUniqueInput>;
  disconnect?: Maybe<ContactWhereUniqueInput[] | ContactWhereUniqueInput>;
  update?: Maybe<
    | ContactUpdateWithWhereUniqueWithoutOrgInput[]
    | ContactUpdateWithWhereUniqueWithoutOrgInput
  >;
  upsert?: Maybe<
    | ContactUpsertWithWhereUniqueWithoutOrgInput[]
    | ContactUpsertWithWhereUniqueWithoutOrgInput
  >;
  deleteMany?: Maybe<ContactScalarWhereInput[] | ContactScalarWhereInput>;
  updateMany?: Maybe<
    | ContactUpdateManyWithWhereNestedInput[]
    | ContactUpdateManyWithWhereNestedInput
  >;
}

export interface ContactUpdateWithWhereUniqueWithoutOrgInput {
  where: ContactWhereUniqueInput;
  data: ContactUpdateWithoutOrgDataInput;
}

export interface ContactUpdateWithoutOrgDataInput {
  accounts?: Maybe<AccountUpdateManyWithoutPrimaryContactInput>;
  city?: Maybe<String>;
  contactCustomValues?: Maybe<ContactCustomValueUpdateManyWithoutContactInput>;
  email?: Maybe<String>;
  first?: Maybe<String>;
  last?: Maybe<String>;
  middle?: Maybe<String>;
  phone?: Maybe<String>;
  state?: Maybe<String>;
  streetAddress?: Maybe<String>;
  users?: Maybe<UserUpdateManyWithoutContactInput>;
  zip?: Maybe<String>;
}

export interface ContactUpsertWithWhereUniqueWithoutOrgInput {
  where: ContactWhereUniqueInput;
  update: ContactUpdateWithoutOrgDataInput;
  create: ContactCreateWithoutOrgInput;
}

export interface ContactScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  first?: Maybe<String>;
  first_not?: Maybe<String>;
  first_in?: Maybe<String[] | String>;
  first_not_in?: Maybe<String[] | String>;
  first_lt?: Maybe<String>;
  first_lte?: Maybe<String>;
  first_gt?: Maybe<String>;
  first_gte?: Maybe<String>;
  first_contains?: Maybe<String>;
  first_not_contains?: Maybe<String>;
  first_starts_with?: Maybe<String>;
  first_not_starts_with?: Maybe<String>;
  first_ends_with?: Maybe<String>;
  first_not_ends_with?: Maybe<String>;
  last?: Maybe<String>;
  last_not?: Maybe<String>;
  last_in?: Maybe<String[] | String>;
  last_not_in?: Maybe<String[] | String>;
  last_lt?: Maybe<String>;
  last_lte?: Maybe<String>;
  last_gt?: Maybe<String>;
  last_gte?: Maybe<String>;
  last_contains?: Maybe<String>;
  last_not_contains?: Maybe<String>;
  last_starts_with?: Maybe<String>;
  last_not_starts_with?: Maybe<String>;
  last_ends_with?: Maybe<String>;
  last_not_ends_with?: Maybe<String>;
  middle?: Maybe<String>;
  middle_not?: Maybe<String>;
  middle_in?: Maybe<String[] | String>;
  middle_not_in?: Maybe<String[] | String>;
  middle_lt?: Maybe<String>;
  middle_lte?: Maybe<String>;
  middle_gt?: Maybe<String>;
  middle_gte?: Maybe<String>;
  middle_contains?: Maybe<String>;
  middle_not_contains?: Maybe<String>;
  middle_starts_with?: Maybe<String>;
  middle_not_starts_with?: Maybe<String>;
  middle_ends_with?: Maybe<String>;
  middle_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  streetAddress?: Maybe<String>;
  streetAddress_not?: Maybe<String>;
  streetAddress_in?: Maybe<String[] | String>;
  streetAddress_not_in?: Maybe<String[] | String>;
  streetAddress_lt?: Maybe<String>;
  streetAddress_lte?: Maybe<String>;
  streetAddress_gt?: Maybe<String>;
  streetAddress_gte?: Maybe<String>;
  streetAddress_contains?: Maybe<String>;
  streetAddress_not_contains?: Maybe<String>;
  streetAddress_starts_with?: Maybe<String>;
  streetAddress_not_starts_with?: Maybe<String>;
  streetAddress_ends_with?: Maybe<String>;
  streetAddress_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  zip?: Maybe<String>;
  zip_not?: Maybe<String>;
  zip_in?: Maybe<String[] | String>;
  zip_not_in?: Maybe<String[] | String>;
  zip_lt?: Maybe<String>;
  zip_lte?: Maybe<String>;
  zip_gt?: Maybe<String>;
  zip_gte?: Maybe<String>;
  zip_contains?: Maybe<String>;
  zip_not_contains?: Maybe<String>;
  zip_starts_with?: Maybe<String>;
  zip_not_starts_with?: Maybe<String>;
  zip_ends_with?: Maybe<String>;
  zip_not_ends_with?: Maybe<String>;
  AND?: Maybe<ContactScalarWhereInput[] | ContactScalarWhereInput>;
  OR?: Maybe<ContactScalarWhereInput[] | ContactScalarWhereInput>;
  NOT?: Maybe<ContactScalarWhereInput[] | ContactScalarWhereInput>;
}

export interface ContactUpdateManyWithWhereNestedInput {
  where: ContactScalarWhereInput;
  data: ContactUpdateManyDataInput;
}

export interface ContactUpdateManyDataInput {
  city?: Maybe<String>;
  email?: Maybe<String>;
  first?: Maybe<String>;
  last?: Maybe<String>;
  middle?: Maybe<String>;
  phone?: Maybe<String>;
  state?: Maybe<String>;
  streetAddress?: Maybe<String>;
  zip?: Maybe<String>;
}

export interface OrgUpsertWithoutContactCustomValuesInput {
  update: OrgUpdateWithoutContactCustomValuesDataInput;
  create: OrgCreateWithoutContactCustomValuesInput;
}

export interface ContactCustomValueUpsertWithWhereUniqueWithoutContactCustomFieldInput {
  where: ContactCustomValueWhereUniqueInput;
  update: ContactCustomValueUpdateWithoutContactCustomFieldDataInput;
  create: ContactCustomValueCreateWithoutContactCustomFieldInput;
}

export interface ContactCustomFieldUpsertWithWhereUniqueWithoutOrgInput {
  where: ContactCustomFieldWhereUniqueInput;
  update: ContactCustomFieldUpdateWithoutOrgDataInput;
  create: ContactCustomFieldCreateWithoutOrgInput;
}

export interface ContactCustomFieldScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  fieldName?: Maybe<String>;
  fieldName_not?: Maybe<String>;
  fieldName_in?: Maybe<String[] | String>;
  fieldName_not_in?: Maybe<String[] | String>;
  fieldName_lt?: Maybe<String>;
  fieldName_lte?: Maybe<String>;
  fieldName_gt?: Maybe<String>;
  fieldName_gte?: Maybe<String>;
  fieldName_contains?: Maybe<String>;
  fieldName_not_contains?: Maybe<String>;
  fieldName_starts_with?: Maybe<String>;
  fieldName_not_starts_with?: Maybe<String>;
  fieldName_ends_with?: Maybe<String>;
  fieldName_not_ends_with?: Maybe<String>;
  label?: Maybe<String>;
  label_not?: Maybe<String>;
  label_in?: Maybe<String[] | String>;
  label_not_in?: Maybe<String[] | String>;
  label_lt?: Maybe<String>;
  label_lte?: Maybe<String>;
  label_gt?: Maybe<String>;
  label_gte?: Maybe<String>;
  label_contains?: Maybe<String>;
  label_not_contains?: Maybe<String>;
  label_starts_with?: Maybe<String>;
  label_not_starts_with?: Maybe<String>;
  label_ends_with?: Maybe<String>;
  label_not_ends_with?: Maybe<String>;
  max?: Maybe<String>;
  max_not?: Maybe<String>;
  max_in?: Maybe<String[] | String>;
  max_not_in?: Maybe<String[] | String>;
  max_lt?: Maybe<String>;
  max_lte?: Maybe<String>;
  max_gt?: Maybe<String>;
  max_gte?: Maybe<String>;
  max_contains?: Maybe<String>;
  max_not_contains?: Maybe<String>;
  max_starts_with?: Maybe<String>;
  max_not_starts_with?: Maybe<String>;
  max_ends_with?: Maybe<String>;
  max_not_ends_with?: Maybe<String>;
  min?: Maybe<String>;
  min_not?: Maybe<String>;
  min_in?: Maybe<String[] | String>;
  min_not_in?: Maybe<String[] | String>;
  min_lt?: Maybe<String>;
  min_lte?: Maybe<String>;
  min_gt?: Maybe<String>;
  min_gte?: Maybe<String>;
  min_contains?: Maybe<String>;
  min_not_contains?: Maybe<String>;
  min_starts_with?: Maybe<String>;
  min_not_starts_with?: Maybe<String>;
  min_ends_with?: Maybe<String>;
  min_not_ends_with?: Maybe<String>;
  placeholder?: Maybe<String>;
  placeholder_not?: Maybe<String>;
  placeholder_in?: Maybe<String[] | String>;
  placeholder_not_in?: Maybe<String[] | String>;
  placeholder_lt?: Maybe<String>;
  placeholder_lte?: Maybe<String>;
  placeholder_gt?: Maybe<String>;
  placeholder_gte?: Maybe<String>;
  placeholder_contains?: Maybe<String>;
  placeholder_not_contains?: Maybe<String>;
  placeholder_starts_with?: Maybe<String>;
  placeholder_not_starts_with?: Maybe<String>;
  placeholder_ends_with?: Maybe<String>;
  placeholder_not_ends_with?: Maybe<String>;
  required?: Maybe<Boolean>;
  required_not?: Maybe<Boolean>;
  tag?: Maybe<String>;
  tag_not?: Maybe<String>;
  tag_in?: Maybe<String[] | String>;
  tag_not_in?: Maybe<String[] | String>;
  tag_lt?: Maybe<String>;
  tag_lte?: Maybe<String>;
  tag_gt?: Maybe<String>;
  tag_gte?: Maybe<String>;
  tag_contains?: Maybe<String>;
  tag_not_contains?: Maybe<String>;
  tag_starts_with?: Maybe<String>;
  tag_not_starts_with?: Maybe<String>;
  tag_ends_with?: Maybe<String>;
  tag_not_ends_with?: Maybe<String>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    ContactCustomFieldScalarWhereInput[] | ContactCustomFieldScalarWhereInput
  >;
  OR?: Maybe<
    ContactCustomFieldScalarWhereInput[] | ContactCustomFieldScalarWhereInput
  >;
  NOT?: Maybe<
    ContactCustomFieldScalarWhereInput[] | ContactCustomFieldScalarWhereInput
  >;
}

export interface ContactCustomFieldUpdateManyWithWhereNestedInput {
  where: ContactCustomFieldScalarWhereInput;
  data: ContactCustomFieldUpdateManyDataInput;
}

export interface ContactCustomFieldUpdateManyDataInput {
  fieldName?: Maybe<String>;
  label?: Maybe<String>;
  max?: Maybe<String>;
  min?: Maybe<String>;
  options?: Maybe<Json>;
  placeholder?: Maybe<String>;
  required?: Maybe<Boolean>;
  tag?: Maybe<String>;
  type?: Maybe<String>;
}

export interface OrgUpsertWithoutAccountsInput {
  update: OrgUpdateWithoutAccountsDataInput;
  create: OrgCreateWithoutAccountsInput;
}

export interface AccountUpsertWithoutAccountCustomValuesInput {
  update: AccountUpdateWithoutAccountCustomValuesDataInput;
  create: AccountCreateWithoutAccountCustomValuesInput;
}

export interface AccountCustomValueUpsertWithWhereUniqueWithoutAccountCustomFieldInput {
  where: AccountCustomValueWhereUniqueInput;
  update: AccountCustomValueUpdateWithoutAccountCustomFieldDataInput;
  create: AccountCustomValueCreateWithoutAccountCustomFieldInput;
}

export interface AccountCustomValueScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    AccountCustomValueScalarWhereInput[] | AccountCustomValueScalarWhereInput
  >;
  OR?: Maybe<
    AccountCustomValueScalarWhereInput[] | AccountCustomValueScalarWhereInput
  >;
  NOT?: Maybe<
    AccountCustomValueScalarWhereInput[] | AccountCustomValueScalarWhereInput
  >;
}

export interface AccountCustomValueUpdateManyWithWhereNestedInput {
  where: AccountCustomValueScalarWhereInput;
  data: AccountCustomValueUpdateManyDataInput;
}

export interface AccountCustomValueUpdateManyDataInput {
  value?: Maybe<String>;
}

export interface AccountCustomFieldUpsertWithWhereUniqueWithoutOrgInput {
  where: AccountCustomFieldWhereUniqueInput;
  update: AccountCustomFieldUpdateWithoutOrgDataInput;
  create: AccountCustomFieldCreateWithoutOrgInput;
}

export interface AccountCustomFieldScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  fieldName?: Maybe<String>;
  fieldName_not?: Maybe<String>;
  fieldName_in?: Maybe<String[] | String>;
  fieldName_not_in?: Maybe<String[] | String>;
  fieldName_lt?: Maybe<String>;
  fieldName_lte?: Maybe<String>;
  fieldName_gt?: Maybe<String>;
  fieldName_gte?: Maybe<String>;
  fieldName_contains?: Maybe<String>;
  fieldName_not_contains?: Maybe<String>;
  fieldName_starts_with?: Maybe<String>;
  fieldName_not_starts_with?: Maybe<String>;
  fieldName_ends_with?: Maybe<String>;
  fieldName_not_ends_with?: Maybe<String>;
  label?: Maybe<String>;
  label_not?: Maybe<String>;
  label_in?: Maybe<String[] | String>;
  label_not_in?: Maybe<String[] | String>;
  label_lt?: Maybe<String>;
  label_lte?: Maybe<String>;
  label_gt?: Maybe<String>;
  label_gte?: Maybe<String>;
  label_contains?: Maybe<String>;
  label_not_contains?: Maybe<String>;
  label_starts_with?: Maybe<String>;
  label_not_starts_with?: Maybe<String>;
  label_ends_with?: Maybe<String>;
  label_not_ends_with?: Maybe<String>;
  max?: Maybe<String>;
  max_not?: Maybe<String>;
  max_in?: Maybe<String[] | String>;
  max_not_in?: Maybe<String[] | String>;
  max_lt?: Maybe<String>;
  max_lte?: Maybe<String>;
  max_gt?: Maybe<String>;
  max_gte?: Maybe<String>;
  max_contains?: Maybe<String>;
  max_not_contains?: Maybe<String>;
  max_starts_with?: Maybe<String>;
  max_not_starts_with?: Maybe<String>;
  max_ends_with?: Maybe<String>;
  max_not_ends_with?: Maybe<String>;
  min?: Maybe<String>;
  min_not?: Maybe<String>;
  min_in?: Maybe<String[] | String>;
  min_not_in?: Maybe<String[] | String>;
  min_lt?: Maybe<String>;
  min_lte?: Maybe<String>;
  min_gt?: Maybe<String>;
  min_gte?: Maybe<String>;
  min_contains?: Maybe<String>;
  min_not_contains?: Maybe<String>;
  min_starts_with?: Maybe<String>;
  min_not_starts_with?: Maybe<String>;
  min_ends_with?: Maybe<String>;
  min_not_ends_with?: Maybe<String>;
  placeholder?: Maybe<String>;
  placeholder_not?: Maybe<String>;
  placeholder_in?: Maybe<String[] | String>;
  placeholder_not_in?: Maybe<String[] | String>;
  placeholder_lt?: Maybe<String>;
  placeholder_lte?: Maybe<String>;
  placeholder_gt?: Maybe<String>;
  placeholder_gte?: Maybe<String>;
  placeholder_contains?: Maybe<String>;
  placeholder_not_contains?: Maybe<String>;
  placeholder_starts_with?: Maybe<String>;
  placeholder_not_starts_with?: Maybe<String>;
  placeholder_ends_with?: Maybe<String>;
  placeholder_not_ends_with?: Maybe<String>;
  required?: Maybe<Boolean>;
  required_not?: Maybe<Boolean>;
  tag?: Maybe<String>;
  tag_not?: Maybe<String>;
  tag_in?: Maybe<String[] | String>;
  tag_not_in?: Maybe<String[] | String>;
  tag_lt?: Maybe<String>;
  tag_lte?: Maybe<String>;
  tag_gt?: Maybe<String>;
  tag_gte?: Maybe<String>;
  tag_contains?: Maybe<String>;
  tag_not_contains?: Maybe<String>;
  tag_starts_with?: Maybe<String>;
  tag_not_starts_with?: Maybe<String>;
  tag_ends_with?: Maybe<String>;
  tag_not_ends_with?: Maybe<String>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    AccountCustomFieldScalarWhereInput[] | AccountCustomFieldScalarWhereInput
  >;
  OR?: Maybe<
    AccountCustomFieldScalarWhereInput[] | AccountCustomFieldScalarWhereInput
  >;
  NOT?: Maybe<
    AccountCustomFieldScalarWhereInput[] | AccountCustomFieldScalarWhereInput
  >;
}

export interface AccountCustomFieldUpdateManyWithWhereNestedInput {
  where: AccountCustomFieldScalarWhereInput;
  data: AccountCustomFieldUpdateManyDataInput;
}

export interface AccountCustomFieldUpdateManyDataInput {
  fieldName?: Maybe<String>;
  label?: Maybe<String>;
  max?: Maybe<String>;
  min?: Maybe<String>;
  options?: Maybe<Json>;
  placeholder?: Maybe<String>;
  required?: Maybe<Boolean>;
  tag?: Maybe<String>;
  type?: Maybe<String>;
}

export interface OrgUpsertWithoutContactCustomFieldsInput {
  update: OrgUpdateWithoutContactCustomFieldsDataInput;
  create: OrgCreateWithoutContactCustomFieldsInput;
}

export interface ContactCustomFieldUpsertWithoutContactCustomValuesInput {
  update: ContactCustomFieldUpdateWithoutContactCustomValuesDataInput;
  create: ContactCustomFieldCreateWithoutContactCustomValuesInput;
}

export interface ContactCustomValueUpsertWithWhereUniqueWithoutContactInput {
  where: ContactCustomValueWhereUniqueInput;
  update: ContactCustomValueUpdateWithoutContactDataInput;
  create: ContactCustomValueCreateWithoutContactInput;
}

export interface ContactUpsertWithoutAccountsInput {
  update: ContactUpdateWithoutAccountsDataInput;
  create: ContactCreateWithoutAccountsInput;
}

export interface AccountUpsertWithWhereUniqueWithoutOrgInput {
  where: AccountWhereUniqueInput;
  update: AccountUpdateWithoutOrgDataInput;
  create: AccountCreateWithoutOrgInput;
}

export interface OrgUpsertWithoutAccountCustomFieldsInput {
  update: OrgUpdateWithoutAccountCustomFieldsDataInput;
  create: OrgCreateWithoutAccountCustomFieldsInput;
}

export interface AccountCustomFieldUpsertWithoutAccountCustomValuesInput {
  update: AccountCustomFieldUpdateWithoutAccountCustomValuesDataInput;
  create: AccountCustomFieldCreateWithoutAccountCustomValuesInput;
}

export interface AccountCustomValueUpsertWithWhereUniqueWithoutAccountInput {
  where: AccountCustomValueWhereUniqueInput;
  update: AccountCustomValueUpdateWithoutAccountDataInput;
  create: AccountCustomValueCreateWithoutAccountInput;
}

export interface AccountUpdateManyMutationInput {
  city?: Maybe<String>;
  name?: Maybe<String>;
  primaryEmail?: Maybe<String>;
  primaryPhone?: Maybe<String>;
  state?: Maybe<String>;
  streetAddress?: Maybe<String>;
  zip?: Maybe<String>;
}

export interface AccountCustomFieldCreateInput {
  id?: Maybe<Int>;
  accountCustomValues?: Maybe<
    AccountCustomValueCreateManyWithoutAccountCustomFieldInput
  >;
  fieldName: String;
  label: String;
  max?: Maybe<String>;
  min?: Maybe<String>;
  options?: Maybe<Json>;
  org: OrgCreateOneWithoutAccountCustomFieldsInput;
  placeholder?: Maybe<String>;
  required: Boolean;
  tag: String;
  type?: Maybe<String>;
}

export interface AccountCustomFieldUpdateInput {
  accountCustomValues?: Maybe<
    AccountCustomValueUpdateManyWithoutAccountCustomFieldInput
  >;
  fieldName?: Maybe<String>;
  label?: Maybe<String>;
  max?: Maybe<String>;
  min?: Maybe<String>;
  options?: Maybe<Json>;
  org?: Maybe<OrgUpdateOneRequiredWithoutAccountCustomFieldsInput>;
  placeholder?: Maybe<String>;
  required?: Maybe<Boolean>;
  tag?: Maybe<String>;
  type?: Maybe<String>;
}

export interface AccountCustomFieldUpdateManyMutationInput {
  fieldName?: Maybe<String>;
  label?: Maybe<String>;
  max?: Maybe<String>;
  min?: Maybe<String>;
  options?: Maybe<Json>;
  placeholder?: Maybe<String>;
  required?: Maybe<Boolean>;
  tag?: Maybe<String>;
  type?: Maybe<String>;
}

export interface AccountCustomValueCreateInput {
  id?: Maybe<Int>;
  account: AccountCreateOneWithoutAccountCustomValuesInput;
  accountCustomField: AccountCustomFieldCreateOneWithoutAccountCustomValuesInput;
  value: String;
}

export interface AccountCustomValueUpdateInput {
  account?: Maybe<AccountUpdateOneRequiredWithoutAccountCustomValuesInput>;
  accountCustomField?: Maybe<
    AccountCustomFieldUpdateOneRequiredWithoutAccountCustomValuesInput
  >;
  value?: Maybe<String>;
}

export interface AccountCustomValueUpdateManyMutationInput {
  value?: Maybe<String>;
}

export interface AdminCreateInput {
  id?: Maybe<Int>;
  address: String;
  city: String;
  email: String;
  first: String;
  isSuper?: Maybe<Boolean>;
  last: String;
  password: String;
  rememberToken?: Maybe<String>;
  state: String;
  zip: String;
}

export interface AdminUpdateInput {
  address?: Maybe<String>;
  city?: Maybe<String>;
  email?: Maybe<String>;
  first?: Maybe<String>;
  isSuper?: Maybe<Boolean>;
  last?: Maybe<String>;
  password?: Maybe<String>;
  rememberToken?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<String>;
}

export interface AdminUpdateManyMutationInput {
  address?: Maybe<String>;
  city?: Maybe<String>;
  email?: Maybe<String>;
  first?: Maybe<String>;
  isSuper?: Maybe<Boolean>;
  last?: Maybe<String>;
  password?: Maybe<String>;
  rememberToken?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<String>;
}

export interface ContactCreateInput {
  id?: Maybe<Int>;
  accounts?: Maybe<AccountCreateManyWithoutPrimaryContactInput>;
  city?: Maybe<String>;
  contactCustomValues?: Maybe<ContactCustomValueCreateManyWithoutContactInput>;
  email?: Maybe<String>;
  first: String;
  last: String;
  middle?: Maybe<String>;
  org: OrgCreateOneWithoutContactsInput;
  phone?: Maybe<String>;
  state: String;
  streetAddress?: Maybe<String>;
  users?: Maybe<UserCreateManyWithoutContactInput>;
  zip?: Maybe<String>;
}

export interface ContactUpdateInput {
  accounts?: Maybe<AccountUpdateManyWithoutPrimaryContactInput>;
  city?: Maybe<String>;
  contactCustomValues?: Maybe<ContactCustomValueUpdateManyWithoutContactInput>;
  email?: Maybe<String>;
  first?: Maybe<String>;
  last?: Maybe<String>;
  middle?: Maybe<String>;
  org?: Maybe<OrgUpdateOneRequiredWithoutContactsInput>;
  phone?: Maybe<String>;
  state?: Maybe<String>;
  streetAddress?: Maybe<String>;
  users?: Maybe<UserUpdateManyWithoutContactInput>;
  zip?: Maybe<String>;
}

export interface ContactUpdateManyMutationInput {
  city?: Maybe<String>;
  email?: Maybe<String>;
  first?: Maybe<String>;
  last?: Maybe<String>;
  middle?: Maybe<String>;
  phone?: Maybe<String>;
  state?: Maybe<String>;
  streetAddress?: Maybe<String>;
  zip?: Maybe<String>;
}

export interface ContactCustomFieldCreateInput {
  id?: Maybe<Int>;
  contactCustomValues?: Maybe<
    ContactCustomValueCreateManyWithoutContactCustomFieldInput
  >;
  fieldName: String;
  label: String;
  max?: Maybe<String>;
  min?: Maybe<String>;
  options?: Maybe<Json>;
  org: OrgCreateOneWithoutContactCustomFieldsInput;
  placeholder?: Maybe<String>;
  required: Boolean;
  tag: String;
  type?: Maybe<String>;
}

export interface ContactCustomFieldUpdateInput {
  contactCustomValues?: Maybe<
    ContactCustomValueUpdateManyWithoutContactCustomFieldInput
  >;
  fieldName?: Maybe<String>;
  label?: Maybe<String>;
  max?: Maybe<String>;
  min?: Maybe<String>;
  options?: Maybe<Json>;
  org?: Maybe<OrgUpdateOneRequiredWithoutContactCustomFieldsInput>;
  placeholder?: Maybe<String>;
  required?: Maybe<Boolean>;
  tag?: Maybe<String>;
  type?: Maybe<String>;
}

export interface ContactCustomFieldUpdateManyMutationInput {
  fieldName?: Maybe<String>;
  label?: Maybe<String>;
  max?: Maybe<String>;
  min?: Maybe<String>;
  options?: Maybe<Json>;
  placeholder?: Maybe<String>;
  required?: Maybe<Boolean>;
  tag?: Maybe<String>;
  type?: Maybe<String>;
}

export interface ContactCustomValueCreateInput {
  id?: Maybe<Int>;
  contact: ContactCreateOneWithoutContactCustomValuesInput;
  contactCustomField: ContactCustomFieldCreateOneWithoutContactCustomValuesInput;
  org: OrgCreateOneWithoutContactCustomValuesInput;
  value: String;
}

export interface ContactCustomValueUpdateInput {
  contact?: Maybe<ContactUpdateOneRequiredWithoutContactCustomValuesInput>;
  contactCustomField?: Maybe<
    ContactCustomFieldUpdateOneRequiredWithoutContactCustomValuesInput
  >;
  org?: Maybe<OrgUpdateOneRequiredWithoutContactCustomValuesInput>;
  value?: Maybe<String>;
}

export interface ContactCustomValueUpdateManyMutationInput {
  value?: Maybe<String>;
}

export interface JobCreateInput {
  id?: Maybe<Int>;
  attempts: Boolean;
  availableAt: Int;
  payload: String;
  queue: String;
  reservedAt?: Maybe<Int>;
}

export interface JobUpdateInput {
  attempts?: Maybe<Boolean>;
  availableAt?: Maybe<Int>;
  payload?: Maybe<String>;
  queue?: Maybe<String>;
  reservedAt?: Maybe<Int>;
}

export interface JobUpdateManyMutationInput {
  attempts?: Maybe<Boolean>;
  availableAt?: Maybe<Int>;
  payload?: Maybe<String>;
  queue?: Maybe<String>;
  reservedAt?: Maybe<Int>;
}

export interface MigrationCreateInput {
  id?: Maybe<Int>;
  batch: Int;
  migration: String;
}

export interface MigrationUpdateInput {
  batch?: Maybe<Int>;
  migration?: Maybe<String>;
}

export interface MigrationUpdateManyMutationInput {
  batch?: Maybe<Int>;
  migration?: Maybe<String>;
}

export interface OrgCreateInput {
  id?: Maybe<Int>;
  accountCustomFields?: Maybe<AccountCustomFieldCreateManyWithoutOrgInput>;
  accounts?: Maybe<AccountCreateManyWithoutOrgInput>;
  contactCustomFields?: Maybe<ContactCustomFieldCreateManyWithoutOrgInput>;
  contactCustomValues?: Maybe<ContactCustomValueCreateManyWithoutOrgInput>;
  contacts?: Maybe<ContactCreateManyWithoutOrgInput>;
  name: String;
  phone: String;
  primaryEmail: String;
}

export interface OrgUpdateInput {
  accountCustomFields?: Maybe<AccountCustomFieldUpdateManyWithoutOrgInput>;
  accounts?: Maybe<AccountUpdateManyWithoutOrgInput>;
  contactCustomFields?: Maybe<ContactCustomFieldUpdateManyWithoutOrgInput>;
  contactCustomValues?: Maybe<ContactCustomValueUpdateManyWithoutOrgInput>;
  contacts?: Maybe<ContactUpdateManyWithoutOrgInput>;
  name?: Maybe<String>;
  phone?: Maybe<String>;
  primaryEmail?: Maybe<String>;
}

export interface OrgUpdateManyMutationInput {
  name?: Maybe<String>;
  phone?: Maybe<String>;
  primaryEmail?: Maybe<String>;
}

export interface PasswordResetCreateInput {
  email: String;
  token: String;
}

export interface PasswordResetUpdateManyMutationInput {
  email?: Maybe<String>;
  token?: Maybe<String>;
}

export interface UserCreateInput {
  id?: Maybe<Int>;
  contact: ContactCreateOneWithoutUsersInput;
  email: String;
  emailVerifiedAt?: Maybe<DateTimeInput>;
  orgId: Int;
  password: String;
  rememberToken?: Maybe<String>;
  role?: Maybe<UsersRoleEnum>;
}

export interface ContactCreateOneWithoutUsersInput {
  create?: Maybe<ContactCreateWithoutUsersInput>;
  connect?: Maybe<ContactWhereUniqueInput>;
}

export interface ContactCreateWithoutUsersInput {
  id?: Maybe<Int>;
  accounts?: Maybe<AccountCreateManyWithoutPrimaryContactInput>;
  city?: Maybe<String>;
  contactCustomValues?: Maybe<ContactCustomValueCreateManyWithoutContactInput>;
  email?: Maybe<String>;
  first: String;
  last: String;
  middle?: Maybe<String>;
  org: OrgCreateOneWithoutContactsInput;
  phone?: Maybe<String>;
  state: String;
  streetAddress?: Maybe<String>;
  zip?: Maybe<String>;
}

export interface UserUpdateInput {
  contact?: Maybe<ContactUpdateOneRequiredWithoutUsersInput>;
  email?: Maybe<String>;
  emailVerifiedAt?: Maybe<DateTimeInput>;
  orgId?: Maybe<Int>;
  password?: Maybe<String>;
  rememberToken?: Maybe<String>;
  role?: Maybe<UsersRoleEnum>;
}

export interface ContactUpdateOneRequiredWithoutUsersInput {
  create?: Maybe<ContactCreateWithoutUsersInput>;
  update?: Maybe<ContactUpdateWithoutUsersDataInput>;
  upsert?: Maybe<ContactUpsertWithoutUsersInput>;
  connect?: Maybe<ContactWhereUniqueInput>;
}

export interface ContactUpdateWithoutUsersDataInput {
  accounts?: Maybe<AccountUpdateManyWithoutPrimaryContactInput>;
  city?: Maybe<String>;
  contactCustomValues?: Maybe<ContactCustomValueUpdateManyWithoutContactInput>;
  email?: Maybe<String>;
  first?: Maybe<String>;
  last?: Maybe<String>;
  middle?: Maybe<String>;
  org?: Maybe<OrgUpdateOneRequiredWithoutContactsInput>;
  phone?: Maybe<String>;
  state?: Maybe<String>;
  streetAddress?: Maybe<String>;
  zip?: Maybe<String>;
}

export interface ContactUpsertWithoutUsersInput {
  update: ContactUpdateWithoutUsersDataInput;
  create: ContactCreateWithoutUsersInput;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  emailVerifiedAt?: Maybe<DateTimeInput>;
  orgId?: Maybe<Int>;
  password?: Maybe<String>;
  rememberToken?: Maybe<String>;
  role?: Maybe<UsersRoleEnum>;
}

export interface AccountSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AccountWhereInput>;
  AND?: Maybe<AccountSubscriptionWhereInput[] | AccountSubscriptionWhereInput>;
  OR?: Maybe<AccountSubscriptionWhereInput[] | AccountSubscriptionWhereInput>;
  NOT?: Maybe<AccountSubscriptionWhereInput[] | AccountSubscriptionWhereInput>;
}

export interface AccountCustomFieldSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AccountCustomFieldWhereInput>;
  AND?: Maybe<
    | AccountCustomFieldSubscriptionWhereInput[]
    | AccountCustomFieldSubscriptionWhereInput
  >;
  OR?: Maybe<
    | AccountCustomFieldSubscriptionWhereInput[]
    | AccountCustomFieldSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | AccountCustomFieldSubscriptionWhereInput[]
    | AccountCustomFieldSubscriptionWhereInput
  >;
}

export interface AccountCustomValueSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AccountCustomValueWhereInput>;
  AND?: Maybe<
    | AccountCustomValueSubscriptionWhereInput[]
    | AccountCustomValueSubscriptionWhereInput
  >;
  OR?: Maybe<
    | AccountCustomValueSubscriptionWhereInput[]
    | AccountCustomValueSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | AccountCustomValueSubscriptionWhereInput[]
    | AccountCustomValueSubscriptionWhereInput
  >;
}

export interface AdminSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AdminWhereInput>;
  AND?: Maybe<AdminSubscriptionWhereInput[] | AdminSubscriptionWhereInput>;
  OR?: Maybe<AdminSubscriptionWhereInput[] | AdminSubscriptionWhereInput>;
  NOT?: Maybe<AdminSubscriptionWhereInput[] | AdminSubscriptionWhereInput>;
}

export interface ContactSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ContactWhereInput>;
  AND?: Maybe<ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput>;
  OR?: Maybe<ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput>;
  NOT?: Maybe<ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput>;
}

export interface ContactCustomFieldSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ContactCustomFieldWhereInput>;
  AND?: Maybe<
    | ContactCustomFieldSubscriptionWhereInput[]
    | ContactCustomFieldSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ContactCustomFieldSubscriptionWhereInput[]
    | ContactCustomFieldSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ContactCustomFieldSubscriptionWhereInput[]
    | ContactCustomFieldSubscriptionWhereInput
  >;
}

export interface ContactCustomValueSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ContactCustomValueWhereInput>;
  AND?: Maybe<
    | ContactCustomValueSubscriptionWhereInput[]
    | ContactCustomValueSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ContactCustomValueSubscriptionWhereInput[]
    | ContactCustomValueSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ContactCustomValueSubscriptionWhereInput[]
    | ContactCustomValueSubscriptionWhereInput
  >;
}

export interface JobSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<JobWhereInput>;
  AND?: Maybe<JobSubscriptionWhereInput[] | JobSubscriptionWhereInput>;
  OR?: Maybe<JobSubscriptionWhereInput[] | JobSubscriptionWhereInput>;
  NOT?: Maybe<JobSubscriptionWhereInput[] | JobSubscriptionWhereInput>;
}

export interface MigrationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MigrationWhereInput>;
  AND?: Maybe<
    MigrationSubscriptionWhereInput[] | MigrationSubscriptionWhereInput
  >;
  OR?: Maybe<
    MigrationSubscriptionWhereInput[] | MigrationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    MigrationSubscriptionWhereInput[] | MigrationSubscriptionWhereInput
  >;
}

export interface OrgSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OrgWhereInput>;
  AND?: Maybe<OrgSubscriptionWhereInput[] | OrgSubscriptionWhereInput>;
  OR?: Maybe<OrgSubscriptionWhereInput[] | OrgSubscriptionWhereInput>;
  NOT?: Maybe<OrgSubscriptionWhereInput[] | OrgSubscriptionWhereInput>;
}

export interface PasswordResetSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PasswordResetWhereInput>;
  AND?: Maybe<
    PasswordResetSubscriptionWhereInput[] | PasswordResetSubscriptionWhereInput
  >;
  OR?: Maybe<
    PasswordResetSubscriptionWhereInput[] | PasswordResetSubscriptionWhereInput
  >;
  NOT?: Maybe<
    PasswordResetSubscriptionWhereInput[] | PasswordResetSubscriptionWhereInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Account {
  id: Int;
  city: String;
  createdAt?: DateTimeOutput;
  name: String;
  primaryEmail: String;
  primaryPhone: String;
  state: String;
  streetAddress: String;
  updatedAt?: DateTimeOutput;
  zip: String;
}

export interface AccountPromise extends Promise<Account>, Fragmentable {
  id: () => Promise<Int>;
  accountCustomValues: <T = FragmentableArray<AccountCustomValue>>(args?: {
    where?: AccountCustomValueWhereInput;
    orderBy?: AccountCustomValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  city: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  org: <T = OrgPromise>() => T;
  primaryContact: <T = ContactPromise>() => T;
  primaryEmail: () => Promise<String>;
  primaryPhone: () => Promise<String>;
  state: () => Promise<String>;
  streetAddress: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  zip: () => Promise<String>;
}

export interface AccountSubscription
  extends Promise<AsyncIterator<Account>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  accountCustomValues: <
    T = Promise<AsyncIterator<AccountCustomValueSubscription>>
  >(args?: {
    where?: AccountCustomValueWhereInput;
    orderBy?: AccountCustomValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  city: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  org: <T = OrgSubscription>() => T;
  primaryContact: <T = ContactSubscription>() => T;
  primaryEmail: () => Promise<AsyncIterator<String>>;
  primaryPhone: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  streetAddress: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  zip: () => Promise<AsyncIterator<String>>;
}

export interface AccountNullablePromise
  extends Promise<Account | null>,
    Fragmentable {
  id: () => Promise<Int>;
  accountCustomValues: <T = FragmentableArray<AccountCustomValue>>(args?: {
    where?: AccountCustomValueWhereInput;
    orderBy?: AccountCustomValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  city: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  org: <T = OrgPromise>() => T;
  primaryContact: <T = ContactPromise>() => T;
  primaryEmail: () => Promise<String>;
  primaryPhone: () => Promise<String>;
  state: () => Promise<String>;
  streetAddress: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  zip: () => Promise<String>;
}

export interface AccountCustomValue {
  id: Int;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  value: String;
}

export interface AccountCustomValuePromise
  extends Promise<AccountCustomValue>,
    Fragmentable {
  id: () => Promise<Int>;
  account: <T = AccountPromise>() => T;
  accountCustomField: <T = AccountCustomFieldPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  value: () => Promise<String>;
}

export interface AccountCustomValueSubscription
  extends Promise<AsyncIterator<AccountCustomValue>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  account: <T = AccountSubscription>() => T;
  accountCustomField: <T = AccountCustomFieldSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface AccountCustomValueNullablePromise
  extends Promise<AccountCustomValue | null>,
    Fragmentable {
  id: () => Promise<Int>;
  account: <T = AccountPromise>() => T;
  accountCustomField: <T = AccountCustomFieldPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  value: () => Promise<String>;
}

export interface AccountCustomField {
  id: Int;
  createdAt?: DateTimeOutput;
  fieldName: String;
  label: String;
  max?: String;
  min?: String;
  options?: Json;
  placeholder?: String;
  required: Boolean;
  tag: String;
  type?: String;
  updatedAt?: DateTimeOutput;
}

export interface AccountCustomFieldPromise
  extends Promise<AccountCustomField>,
    Fragmentable {
  id: () => Promise<Int>;
  accountCustomValues: <T = FragmentableArray<AccountCustomValue>>(args?: {
    where?: AccountCustomValueWhereInput;
    orderBy?: AccountCustomValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  fieldName: () => Promise<String>;
  label: () => Promise<String>;
  max: () => Promise<String>;
  min: () => Promise<String>;
  options: () => Promise<Json>;
  org: <T = OrgPromise>() => T;
  placeholder: () => Promise<String>;
  required: () => Promise<Boolean>;
  tag: () => Promise<String>;
  type: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AccountCustomFieldSubscription
  extends Promise<AsyncIterator<AccountCustomField>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  accountCustomValues: <
    T = Promise<AsyncIterator<AccountCustomValueSubscription>>
  >(args?: {
    where?: AccountCustomValueWhereInput;
    orderBy?: AccountCustomValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  fieldName: () => Promise<AsyncIterator<String>>;
  label: () => Promise<AsyncIterator<String>>;
  max: () => Promise<AsyncIterator<String>>;
  min: () => Promise<AsyncIterator<String>>;
  options: () => Promise<AsyncIterator<Json>>;
  org: <T = OrgSubscription>() => T;
  placeholder: () => Promise<AsyncIterator<String>>;
  required: () => Promise<AsyncIterator<Boolean>>;
  tag: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AccountCustomFieldNullablePromise
  extends Promise<AccountCustomField | null>,
    Fragmentable {
  id: () => Promise<Int>;
  accountCustomValues: <T = FragmentableArray<AccountCustomValue>>(args?: {
    where?: AccountCustomValueWhereInput;
    orderBy?: AccountCustomValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  fieldName: () => Promise<String>;
  label: () => Promise<String>;
  max: () => Promise<String>;
  min: () => Promise<String>;
  options: () => Promise<Json>;
  org: <T = OrgPromise>() => T;
  placeholder: () => Promise<String>;
  required: () => Promise<Boolean>;
  tag: () => Promise<String>;
  type: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Org {
  id: Int;
  createdAt?: DateTimeOutput;
  name: String;
  phone: String;
  primaryEmail: String;
  updatedAt?: DateTimeOutput;
}

export interface OrgPromise extends Promise<Org>, Fragmentable {
  id: () => Promise<Int>;
  accountCustomFields: <T = FragmentableArray<AccountCustomField>>(args?: {
    where?: AccountCustomFieldWhereInput;
    orderBy?: AccountCustomFieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  accounts: <T = FragmentableArray<Account>>(args?: {
    where?: AccountWhereInput;
    orderBy?: AccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contactCustomFields: <T = FragmentableArray<ContactCustomField>>(args?: {
    where?: ContactCustomFieldWhereInput;
    orderBy?: ContactCustomFieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contactCustomValues: <T = FragmentableArray<ContactCustomValue>>(args?: {
    where?: ContactCustomValueWhereInput;
    orderBy?: ContactCustomValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contacts: <T = FragmentableArray<Contact>>(args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  phone: () => Promise<String>;
  primaryEmail: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OrgSubscription
  extends Promise<AsyncIterator<Org>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  accountCustomFields: <
    T = Promise<AsyncIterator<AccountCustomFieldSubscription>>
  >(args?: {
    where?: AccountCustomFieldWhereInput;
    orderBy?: AccountCustomFieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  accounts: <T = Promise<AsyncIterator<AccountSubscription>>>(args?: {
    where?: AccountWhereInput;
    orderBy?: AccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contactCustomFields: <
    T = Promise<AsyncIterator<ContactCustomFieldSubscription>>
  >(args?: {
    where?: ContactCustomFieldWhereInput;
    orderBy?: ContactCustomFieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contactCustomValues: <
    T = Promise<AsyncIterator<ContactCustomValueSubscription>>
  >(args?: {
    where?: ContactCustomValueWhereInput;
    orderBy?: ContactCustomValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contacts: <T = Promise<AsyncIterator<ContactSubscription>>>(args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  primaryEmail: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface OrgNullablePromise extends Promise<Org | null>, Fragmentable {
  id: () => Promise<Int>;
  accountCustomFields: <T = FragmentableArray<AccountCustomField>>(args?: {
    where?: AccountCustomFieldWhereInput;
    orderBy?: AccountCustomFieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  accounts: <T = FragmentableArray<Account>>(args?: {
    where?: AccountWhereInput;
    orderBy?: AccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contactCustomFields: <T = FragmentableArray<ContactCustomField>>(args?: {
    where?: ContactCustomFieldWhereInput;
    orderBy?: ContactCustomFieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contactCustomValues: <T = FragmentableArray<ContactCustomValue>>(args?: {
    where?: ContactCustomValueWhereInput;
    orderBy?: ContactCustomValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contacts: <T = FragmentableArray<Contact>>(args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  phone: () => Promise<String>;
  primaryEmail: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ContactCustomField {
  id: Int;
  createdAt?: DateTimeOutput;
  fieldName: String;
  label: String;
  max?: String;
  min?: String;
  options?: Json;
  placeholder?: String;
  required: Boolean;
  tag: String;
  type?: String;
  updatedAt?: DateTimeOutput;
}

export interface ContactCustomFieldPromise
  extends Promise<ContactCustomField>,
    Fragmentable {
  id: () => Promise<Int>;
  contactCustomValues: <T = FragmentableArray<ContactCustomValue>>(args?: {
    where?: ContactCustomValueWhereInput;
    orderBy?: ContactCustomValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  fieldName: () => Promise<String>;
  label: () => Promise<String>;
  max: () => Promise<String>;
  min: () => Promise<String>;
  options: () => Promise<Json>;
  org: <T = OrgPromise>() => T;
  placeholder: () => Promise<String>;
  required: () => Promise<Boolean>;
  tag: () => Promise<String>;
  type: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ContactCustomFieldSubscription
  extends Promise<AsyncIterator<ContactCustomField>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  contactCustomValues: <
    T = Promise<AsyncIterator<ContactCustomValueSubscription>>
  >(args?: {
    where?: ContactCustomValueWhereInput;
    orderBy?: ContactCustomValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  fieldName: () => Promise<AsyncIterator<String>>;
  label: () => Promise<AsyncIterator<String>>;
  max: () => Promise<AsyncIterator<String>>;
  min: () => Promise<AsyncIterator<String>>;
  options: () => Promise<AsyncIterator<Json>>;
  org: <T = OrgSubscription>() => T;
  placeholder: () => Promise<AsyncIterator<String>>;
  required: () => Promise<AsyncIterator<Boolean>>;
  tag: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ContactCustomFieldNullablePromise
  extends Promise<ContactCustomField | null>,
    Fragmentable {
  id: () => Promise<Int>;
  contactCustomValues: <T = FragmentableArray<ContactCustomValue>>(args?: {
    where?: ContactCustomValueWhereInput;
    orderBy?: ContactCustomValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  fieldName: () => Promise<String>;
  label: () => Promise<String>;
  max: () => Promise<String>;
  min: () => Promise<String>;
  options: () => Promise<Json>;
  org: <T = OrgPromise>() => T;
  placeholder: () => Promise<String>;
  required: () => Promise<Boolean>;
  tag: () => Promise<String>;
  type: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ContactCustomValue {
  id: Int;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  value: String;
}

export interface ContactCustomValuePromise
  extends Promise<ContactCustomValue>,
    Fragmentable {
  id: () => Promise<Int>;
  contact: <T = ContactPromise>() => T;
  contactCustomField: <T = ContactCustomFieldPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  org: <T = OrgPromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
  value: () => Promise<String>;
}

export interface ContactCustomValueSubscription
  extends Promise<AsyncIterator<ContactCustomValue>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  contact: <T = ContactSubscription>() => T;
  contactCustomField: <T = ContactCustomFieldSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  org: <T = OrgSubscription>() => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface ContactCustomValueNullablePromise
  extends Promise<ContactCustomValue | null>,
    Fragmentable {
  id: () => Promise<Int>;
  contact: <T = ContactPromise>() => T;
  contactCustomField: <T = ContactCustomFieldPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  org: <T = OrgPromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
  value: () => Promise<String>;
}

export interface Contact {
  id: Int;
  city?: String;
  createdAt?: DateTimeOutput;
  email?: String;
  first: String;
  last: String;
  middle?: String;
  phone?: String;
  state: String;
  streetAddress?: String;
  updatedAt?: DateTimeOutput;
  zip?: String;
}

export interface ContactPromise extends Promise<Contact>, Fragmentable {
  id: () => Promise<Int>;
  accounts: <T = FragmentableArray<Account>>(args?: {
    where?: AccountWhereInput;
    orderBy?: AccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  city: () => Promise<String>;
  contactCustomValues: <T = FragmentableArray<ContactCustomValue>>(args?: {
    where?: ContactCustomValueWhereInput;
    orderBy?: ContactCustomValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  first: () => Promise<String>;
  last: () => Promise<String>;
  middle: () => Promise<String>;
  org: <T = OrgPromise>() => T;
  phone: () => Promise<String>;
  state: () => Promise<String>;
  streetAddress: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  zip: () => Promise<String>;
}

export interface ContactSubscription
  extends Promise<AsyncIterator<Contact>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  accounts: <T = Promise<AsyncIterator<AccountSubscription>>>(args?: {
    where?: AccountWhereInput;
    orderBy?: AccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  city: () => Promise<AsyncIterator<String>>;
  contactCustomValues: <
    T = Promise<AsyncIterator<ContactCustomValueSubscription>>
  >(args?: {
    where?: ContactCustomValueWhereInput;
    orderBy?: ContactCustomValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  first: () => Promise<AsyncIterator<String>>;
  last: () => Promise<AsyncIterator<String>>;
  middle: () => Promise<AsyncIterator<String>>;
  org: <T = OrgSubscription>() => T;
  phone: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  streetAddress: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  zip: () => Promise<AsyncIterator<String>>;
}

export interface ContactNullablePromise
  extends Promise<Contact | null>,
    Fragmentable {
  id: () => Promise<Int>;
  accounts: <T = FragmentableArray<Account>>(args?: {
    where?: AccountWhereInput;
    orderBy?: AccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  city: () => Promise<String>;
  contactCustomValues: <T = FragmentableArray<ContactCustomValue>>(args?: {
    where?: ContactCustomValueWhereInput;
    orderBy?: ContactCustomValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  first: () => Promise<String>;
  last: () => Promise<String>;
  middle: () => Promise<String>;
  org: <T = OrgPromise>() => T;
  phone: () => Promise<String>;
  state: () => Promise<String>;
  streetAddress: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  zip: () => Promise<String>;
}

export interface User {
  id: Int;
  createdAt?: DateTimeOutput;
  email: String;
  emailVerifiedAt?: DateTimeOutput;
  orgId: Int;
  password: String;
  rememberToken?: String;
  role: UsersRoleEnum;
  updatedAt?: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<Int>;
  contact: <T = ContactPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  emailVerifiedAt: () => Promise<DateTimeOutput>;
  orgId: () => Promise<Int>;
  password: () => Promise<String>;
  rememberToken: () => Promise<String>;
  role: () => Promise<UsersRoleEnum>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  contact: <T = ContactSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  emailVerifiedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  orgId: () => Promise<AsyncIterator<Int>>;
  password: () => Promise<AsyncIterator<String>>;
  rememberToken: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<UsersRoleEnum>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<Int>;
  contact: <T = ContactPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  emailVerifiedAt: () => Promise<DateTimeOutput>;
  orgId: () => Promise<Int>;
  password: () => Promise<String>;
  rememberToken: () => Promise<String>;
  role: () => Promise<UsersRoleEnum>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AccountConnection {
  pageInfo: PageInfo;
  edges: AccountEdge[];
}

export interface AccountConnectionPromise
  extends Promise<AccountConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AccountEdge>>() => T;
  aggregate: <T = AggregateAccountPromise>() => T;
}

export interface AccountConnectionSubscription
  extends Promise<AsyncIterator<AccountConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AccountEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAccountSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AccountEdge {
  node: Account;
  cursor: String;
}

export interface AccountEdgePromise extends Promise<AccountEdge>, Fragmentable {
  node: <T = AccountPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AccountEdgeSubscription
  extends Promise<AsyncIterator<AccountEdge>>,
    Fragmentable {
  node: <T = AccountSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAccount {
  count: Int;
}

export interface AggregateAccountPromise
  extends Promise<AggregateAccount>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAccountSubscription
  extends Promise<AsyncIterator<AggregateAccount>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AccountCustomFieldConnection {
  pageInfo: PageInfo;
  edges: AccountCustomFieldEdge[];
}

export interface AccountCustomFieldConnectionPromise
  extends Promise<AccountCustomFieldConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AccountCustomFieldEdge>>() => T;
  aggregate: <T = AggregateAccountCustomFieldPromise>() => T;
}

export interface AccountCustomFieldConnectionSubscription
  extends Promise<AsyncIterator<AccountCustomFieldConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<AccountCustomFieldEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateAccountCustomFieldSubscription>() => T;
}

export interface AccountCustomFieldEdge {
  node: AccountCustomField;
  cursor: String;
}

export interface AccountCustomFieldEdgePromise
  extends Promise<AccountCustomFieldEdge>,
    Fragmentable {
  node: <T = AccountCustomFieldPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AccountCustomFieldEdgeSubscription
  extends Promise<AsyncIterator<AccountCustomFieldEdge>>,
    Fragmentable {
  node: <T = AccountCustomFieldSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAccountCustomField {
  count: Int;
}

export interface AggregateAccountCustomFieldPromise
  extends Promise<AggregateAccountCustomField>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAccountCustomFieldSubscription
  extends Promise<AsyncIterator<AggregateAccountCustomField>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AccountCustomValueConnection {
  pageInfo: PageInfo;
  edges: AccountCustomValueEdge[];
}

export interface AccountCustomValueConnectionPromise
  extends Promise<AccountCustomValueConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AccountCustomValueEdge>>() => T;
  aggregate: <T = AggregateAccountCustomValuePromise>() => T;
}

export interface AccountCustomValueConnectionSubscription
  extends Promise<AsyncIterator<AccountCustomValueConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<AccountCustomValueEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateAccountCustomValueSubscription>() => T;
}

export interface AccountCustomValueEdge {
  node: AccountCustomValue;
  cursor: String;
}

export interface AccountCustomValueEdgePromise
  extends Promise<AccountCustomValueEdge>,
    Fragmentable {
  node: <T = AccountCustomValuePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AccountCustomValueEdgeSubscription
  extends Promise<AsyncIterator<AccountCustomValueEdge>>,
    Fragmentable {
  node: <T = AccountCustomValueSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAccountCustomValue {
  count: Int;
}

export interface AggregateAccountCustomValuePromise
  extends Promise<AggregateAccountCustomValue>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAccountCustomValueSubscription
  extends Promise<AsyncIterator<AggregateAccountCustomValue>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Admin {
  id: Int;
  address: String;
  city: String;
  createdAt?: DateTimeOutput;
  email: String;
  first: String;
  isSuper: Boolean;
  last: String;
  password: String;
  rememberToken?: String;
  state: String;
  updatedAt?: DateTimeOutput;
  zip: String;
}

export interface AdminPromise extends Promise<Admin>, Fragmentable {
  id: () => Promise<Int>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  first: () => Promise<String>;
  isSuper: () => Promise<Boolean>;
  last: () => Promise<String>;
  password: () => Promise<String>;
  rememberToken: () => Promise<String>;
  state: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  zip: () => Promise<String>;
}

export interface AdminSubscription
  extends Promise<AsyncIterator<Admin>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  address: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  first: () => Promise<AsyncIterator<String>>;
  isSuper: () => Promise<AsyncIterator<Boolean>>;
  last: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  rememberToken: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  zip: () => Promise<AsyncIterator<String>>;
}

export interface AdminNullablePromise
  extends Promise<Admin | null>,
    Fragmentable {
  id: () => Promise<Int>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  first: () => Promise<String>;
  isSuper: () => Promise<Boolean>;
  last: () => Promise<String>;
  password: () => Promise<String>;
  rememberToken: () => Promise<String>;
  state: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  zip: () => Promise<String>;
}

export interface AdminConnection {
  pageInfo: PageInfo;
  edges: AdminEdge[];
}

export interface AdminConnectionPromise
  extends Promise<AdminConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AdminEdge>>() => T;
  aggregate: <T = AggregateAdminPromise>() => T;
}

export interface AdminConnectionSubscription
  extends Promise<AsyncIterator<AdminConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AdminEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAdminSubscription>() => T;
}

export interface AdminEdge {
  node: Admin;
  cursor: String;
}

export interface AdminEdgePromise extends Promise<AdminEdge>, Fragmentable {
  node: <T = AdminPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AdminEdgeSubscription
  extends Promise<AsyncIterator<AdminEdge>>,
    Fragmentable {
  node: <T = AdminSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAdmin {
  count: Int;
}

export interface AggregateAdminPromise
  extends Promise<AggregateAdmin>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAdminSubscription
  extends Promise<AsyncIterator<AggregateAdmin>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ContactConnection {
  pageInfo: PageInfo;
  edges: ContactEdge[];
}

export interface ContactConnectionPromise
  extends Promise<ContactConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ContactEdge>>() => T;
  aggregate: <T = AggregateContactPromise>() => T;
}

export interface ContactConnectionSubscription
  extends Promise<AsyncIterator<ContactConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ContactEdgeSubscription>>>() => T;
  aggregate: <T = AggregateContactSubscription>() => T;
}

export interface ContactEdge {
  node: Contact;
  cursor: String;
}

export interface ContactEdgePromise extends Promise<ContactEdge>, Fragmentable {
  node: <T = ContactPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ContactEdgeSubscription
  extends Promise<AsyncIterator<ContactEdge>>,
    Fragmentable {
  node: <T = ContactSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateContact {
  count: Int;
}

export interface AggregateContactPromise
  extends Promise<AggregateContact>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateContactSubscription
  extends Promise<AsyncIterator<AggregateContact>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ContactCustomFieldConnection {
  pageInfo: PageInfo;
  edges: ContactCustomFieldEdge[];
}

export interface ContactCustomFieldConnectionPromise
  extends Promise<ContactCustomFieldConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ContactCustomFieldEdge>>() => T;
  aggregate: <T = AggregateContactCustomFieldPromise>() => T;
}

export interface ContactCustomFieldConnectionSubscription
  extends Promise<AsyncIterator<ContactCustomFieldConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ContactCustomFieldEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateContactCustomFieldSubscription>() => T;
}

export interface ContactCustomFieldEdge {
  node: ContactCustomField;
  cursor: String;
}

export interface ContactCustomFieldEdgePromise
  extends Promise<ContactCustomFieldEdge>,
    Fragmentable {
  node: <T = ContactCustomFieldPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ContactCustomFieldEdgeSubscription
  extends Promise<AsyncIterator<ContactCustomFieldEdge>>,
    Fragmentable {
  node: <T = ContactCustomFieldSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateContactCustomField {
  count: Int;
}

export interface AggregateContactCustomFieldPromise
  extends Promise<AggregateContactCustomField>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateContactCustomFieldSubscription
  extends Promise<AsyncIterator<AggregateContactCustomField>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ContactCustomValueConnection {
  pageInfo: PageInfo;
  edges: ContactCustomValueEdge[];
}

export interface ContactCustomValueConnectionPromise
  extends Promise<ContactCustomValueConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ContactCustomValueEdge>>() => T;
  aggregate: <T = AggregateContactCustomValuePromise>() => T;
}

export interface ContactCustomValueConnectionSubscription
  extends Promise<AsyncIterator<ContactCustomValueConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ContactCustomValueEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateContactCustomValueSubscription>() => T;
}

export interface ContactCustomValueEdge {
  node: ContactCustomValue;
  cursor: String;
}

export interface ContactCustomValueEdgePromise
  extends Promise<ContactCustomValueEdge>,
    Fragmentable {
  node: <T = ContactCustomValuePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ContactCustomValueEdgeSubscription
  extends Promise<AsyncIterator<ContactCustomValueEdge>>,
    Fragmentable {
  node: <T = ContactCustomValueSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateContactCustomValue {
  count: Int;
}

export interface AggregateContactCustomValuePromise
  extends Promise<AggregateContactCustomValue>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateContactCustomValueSubscription
  extends Promise<AsyncIterator<AggregateContactCustomValue>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Job {
  id: Int;
  attempts: Boolean;
  availableAt: Int;
  createdAt: Int;
  payload: String;
  queue: String;
  reservedAt?: Int;
}

export interface JobPromise extends Promise<Job>, Fragmentable {
  id: () => Promise<Int>;
  attempts: () => Promise<Boolean>;
  availableAt: () => Promise<Int>;
  createdAt: () => Promise<Int>;
  payload: () => Promise<String>;
  queue: () => Promise<String>;
  reservedAt: () => Promise<Int>;
}

export interface JobSubscription
  extends Promise<AsyncIterator<Job>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  attempts: () => Promise<AsyncIterator<Boolean>>;
  availableAt: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<Int>>;
  payload: () => Promise<AsyncIterator<String>>;
  queue: () => Promise<AsyncIterator<String>>;
  reservedAt: () => Promise<AsyncIterator<Int>>;
}

export interface JobNullablePromise extends Promise<Job | null>, Fragmentable {
  id: () => Promise<Int>;
  attempts: () => Promise<Boolean>;
  availableAt: () => Promise<Int>;
  createdAt: () => Promise<Int>;
  payload: () => Promise<String>;
  queue: () => Promise<String>;
  reservedAt: () => Promise<Int>;
}

export interface JobConnection {
  pageInfo: PageInfo;
  edges: JobEdge[];
}

export interface JobConnectionPromise
  extends Promise<JobConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<JobEdge>>() => T;
  aggregate: <T = AggregateJobPromise>() => T;
}

export interface JobConnectionSubscription
  extends Promise<AsyncIterator<JobConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<JobEdgeSubscription>>>() => T;
  aggregate: <T = AggregateJobSubscription>() => T;
}

export interface JobEdge {
  node: Job;
  cursor: String;
}

export interface JobEdgePromise extends Promise<JobEdge>, Fragmentable {
  node: <T = JobPromise>() => T;
  cursor: () => Promise<String>;
}

export interface JobEdgeSubscription
  extends Promise<AsyncIterator<JobEdge>>,
    Fragmentable {
  node: <T = JobSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateJob {
  count: Int;
}

export interface AggregateJobPromise
  extends Promise<AggregateJob>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateJobSubscription
  extends Promise<AsyncIterator<AggregateJob>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Migration {
  id: Int;
  batch: Int;
  migration: String;
}

export interface MigrationPromise extends Promise<Migration>, Fragmentable {
  id: () => Promise<Int>;
  batch: () => Promise<Int>;
  migration: () => Promise<String>;
}

export interface MigrationSubscription
  extends Promise<AsyncIterator<Migration>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  batch: () => Promise<AsyncIterator<Int>>;
  migration: () => Promise<AsyncIterator<String>>;
}

export interface MigrationNullablePromise
  extends Promise<Migration | null>,
    Fragmentable {
  id: () => Promise<Int>;
  batch: () => Promise<Int>;
  migration: () => Promise<String>;
}

export interface MigrationConnection {
  pageInfo: PageInfo;
  edges: MigrationEdge[];
}

export interface MigrationConnectionPromise
  extends Promise<MigrationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MigrationEdge>>() => T;
  aggregate: <T = AggregateMigrationPromise>() => T;
}

export interface MigrationConnectionSubscription
  extends Promise<AsyncIterator<MigrationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MigrationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMigrationSubscription>() => T;
}

export interface MigrationEdge {
  node: Migration;
  cursor: String;
}

export interface MigrationEdgePromise
  extends Promise<MigrationEdge>,
    Fragmentable {
  node: <T = MigrationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MigrationEdgeSubscription
  extends Promise<AsyncIterator<MigrationEdge>>,
    Fragmentable {
  node: <T = MigrationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMigration {
  count: Int;
}

export interface AggregateMigrationPromise
  extends Promise<AggregateMigration>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMigrationSubscription
  extends Promise<AsyncIterator<AggregateMigration>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrgConnection {
  pageInfo: PageInfo;
  edges: OrgEdge[];
}

export interface OrgConnectionPromise
  extends Promise<OrgConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrgEdge>>() => T;
  aggregate: <T = AggregateOrgPromise>() => T;
}

export interface OrgConnectionSubscription
  extends Promise<AsyncIterator<OrgConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrgEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrgSubscription>() => T;
}

export interface OrgEdge {
  node: Org;
  cursor: String;
}

export interface OrgEdgePromise extends Promise<OrgEdge>, Fragmentable {
  node: <T = OrgPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrgEdgeSubscription
  extends Promise<AsyncIterator<OrgEdge>>,
    Fragmentable {
  node: <T = OrgSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOrg {
  count: Int;
}

export interface AggregateOrgPromise
  extends Promise<AggregateOrg>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrgSubscription
  extends Promise<AsyncIterator<AggregateOrg>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PasswordReset {
  createdAt?: DateTimeOutput;
  email: String;
  token: String;
}

export interface PasswordResetPromise
  extends Promise<PasswordReset>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  token: () => Promise<String>;
}

export interface PasswordResetSubscription
  extends Promise<AsyncIterator<PasswordReset>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  token: () => Promise<AsyncIterator<String>>;
}

export interface PasswordResetNullablePromise
  extends Promise<PasswordReset | null>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  token: () => Promise<String>;
}

export interface PasswordResetConnection {
  pageInfo: PageInfo;
  edges: PasswordResetEdge[];
}

export interface PasswordResetConnectionPromise
  extends Promise<PasswordResetConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PasswordResetEdge>>() => T;
  aggregate: <T = AggregatePasswordResetPromise>() => T;
}

export interface PasswordResetConnectionSubscription
  extends Promise<AsyncIterator<PasswordResetConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PasswordResetEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePasswordResetSubscription>() => T;
}

export interface PasswordResetEdge {
  node: PasswordReset;
  cursor: String;
}

export interface PasswordResetEdgePromise
  extends Promise<PasswordResetEdge>,
    Fragmentable {
  node: <T = PasswordResetPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PasswordResetEdgeSubscription
  extends Promise<AsyncIterator<PasswordResetEdge>>,
    Fragmentable {
  node: <T = PasswordResetSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePasswordReset {
  count: Int;
}

export interface AggregatePasswordResetPromise
  extends Promise<AggregatePasswordReset>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePasswordResetSubscription
  extends Promise<AsyncIterator<AggregatePasswordReset>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AccountSubscriptionPayload {
  mutation: MutationType;
  node: Account;
  updatedFields: String[];
  previousValues: AccountPreviousValues;
}

export interface AccountSubscriptionPayloadPromise
  extends Promise<AccountSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AccountPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AccountPreviousValuesPromise>() => T;
}

export interface AccountSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AccountSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AccountSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AccountPreviousValuesSubscription>() => T;
}

export interface AccountPreviousValues {
  id: Int;
  city: String;
  createdAt?: DateTimeOutput;
  name: String;
  primaryEmail: String;
  primaryPhone: String;
  state: String;
  streetAddress: String;
  updatedAt?: DateTimeOutput;
  zip: String;
}

export interface AccountPreviousValuesPromise
  extends Promise<AccountPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  city: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  primaryEmail: () => Promise<String>;
  primaryPhone: () => Promise<String>;
  state: () => Promise<String>;
  streetAddress: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  zip: () => Promise<String>;
}

export interface AccountPreviousValuesSubscription
  extends Promise<AsyncIterator<AccountPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  city: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  primaryEmail: () => Promise<AsyncIterator<String>>;
  primaryPhone: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  streetAddress: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  zip: () => Promise<AsyncIterator<String>>;
}

export interface AccountCustomFieldSubscriptionPayload {
  mutation: MutationType;
  node: AccountCustomField;
  updatedFields: String[];
  previousValues: AccountCustomFieldPreviousValues;
}

export interface AccountCustomFieldSubscriptionPayloadPromise
  extends Promise<AccountCustomFieldSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AccountCustomFieldPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AccountCustomFieldPreviousValuesPromise>() => T;
}

export interface AccountCustomFieldSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AccountCustomFieldSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AccountCustomFieldSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AccountCustomFieldPreviousValuesSubscription>() => T;
}

export interface AccountCustomFieldPreviousValues {
  id: Int;
  createdAt?: DateTimeOutput;
  fieldName: String;
  label: String;
  max?: String;
  min?: String;
  options?: Json;
  placeholder?: String;
  required: Boolean;
  tag: String;
  type?: String;
  updatedAt?: DateTimeOutput;
}

export interface AccountCustomFieldPreviousValuesPromise
  extends Promise<AccountCustomFieldPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  fieldName: () => Promise<String>;
  label: () => Promise<String>;
  max: () => Promise<String>;
  min: () => Promise<String>;
  options: () => Promise<Json>;
  placeholder: () => Promise<String>;
  required: () => Promise<Boolean>;
  tag: () => Promise<String>;
  type: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AccountCustomFieldPreviousValuesSubscription
  extends Promise<AsyncIterator<AccountCustomFieldPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  fieldName: () => Promise<AsyncIterator<String>>;
  label: () => Promise<AsyncIterator<String>>;
  max: () => Promise<AsyncIterator<String>>;
  min: () => Promise<AsyncIterator<String>>;
  options: () => Promise<AsyncIterator<Json>>;
  placeholder: () => Promise<AsyncIterator<String>>;
  required: () => Promise<AsyncIterator<Boolean>>;
  tag: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AccountCustomValueSubscriptionPayload {
  mutation: MutationType;
  node: AccountCustomValue;
  updatedFields: String[];
  previousValues: AccountCustomValuePreviousValues;
}

export interface AccountCustomValueSubscriptionPayloadPromise
  extends Promise<AccountCustomValueSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AccountCustomValuePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AccountCustomValuePreviousValuesPromise>() => T;
}

export interface AccountCustomValueSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AccountCustomValueSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AccountCustomValueSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AccountCustomValuePreviousValuesSubscription>() => T;
}

export interface AccountCustomValuePreviousValues {
  id: Int;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  value: String;
}

export interface AccountCustomValuePreviousValuesPromise
  extends Promise<AccountCustomValuePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  value: () => Promise<String>;
}

export interface AccountCustomValuePreviousValuesSubscription
  extends Promise<AsyncIterator<AccountCustomValuePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface AdminSubscriptionPayload {
  mutation: MutationType;
  node: Admin;
  updatedFields: String[];
  previousValues: AdminPreviousValues;
}

export interface AdminSubscriptionPayloadPromise
  extends Promise<AdminSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AdminPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AdminPreviousValuesPromise>() => T;
}

export interface AdminSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AdminSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AdminSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AdminPreviousValuesSubscription>() => T;
}

export interface AdminPreviousValues {
  id: Int;
  address: String;
  city: String;
  createdAt?: DateTimeOutput;
  email: String;
  first: String;
  isSuper: Boolean;
  last: String;
  password: String;
  rememberToken?: String;
  state: String;
  updatedAt?: DateTimeOutput;
  zip: String;
}

export interface AdminPreviousValuesPromise
  extends Promise<AdminPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  first: () => Promise<String>;
  isSuper: () => Promise<Boolean>;
  last: () => Promise<String>;
  password: () => Promise<String>;
  rememberToken: () => Promise<String>;
  state: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  zip: () => Promise<String>;
}

export interface AdminPreviousValuesSubscription
  extends Promise<AsyncIterator<AdminPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  address: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  first: () => Promise<AsyncIterator<String>>;
  isSuper: () => Promise<AsyncIterator<Boolean>>;
  last: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  rememberToken: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  zip: () => Promise<AsyncIterator<String>>;
}

export interface ContactSubscriptionPayload {
  mutation: MutationType;
  node: Contact;
  updatedFields: String[];
  previousValues: ContactPreviousValues;
}

export interface ContactSubscriptionPayloadPromise
  extends Promise<ContactSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ContactPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ContactPreviousValuesPromise>() => T;
}

export interface ContactSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ContactSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ContactSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ContactPreviousValuesSubscription>() => T;
}

export interface ContactPreviousValues {
  id: Int;
  city?: String;
  createdAt?: DateTimeOutput;
  email?: String;
  first: String;
  last: String;
  middle?: String;
  phone?: String;
  state: String;
  streetAddress?: String;
  updatedAt?: DateTimeOutput;
  zip?: String;
}

export interface ContactPreviousValuesPromise
  extends Promise<ContactPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  city: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  first: () => Promise<String>;
  last: () => Promise<String>;
  middle: () => Promise<String>;
  phone: () => Promise<String>;
  state: () => Promise<String>;
  streetAddress: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  zip: () => Promise<String>;
}

export interface ContactPreviousValuesSubscription
  extends Promise<AsyncIterator<ContactPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  city: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  first: () => Promise<AsyncIterator<String>>;
  last: () => Promise<AsyncIterator<String>>;
  middle: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  streetAddress: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  zip: () => Promise<AsyncIterator<String>>;
}

export interface ContactCustomFieldSubscriptionPayload {
  mutation: MutationType;
  node: ContactCustomField;
  updatedFields: String[];
  previousValues: ContactCustomFieldPreviousValues;
}

export interface ContactCustomFieldSubscriptionPayloadPromise
  extends Promise<ContactCustomFieldSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ContactCustomFieldPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ContactCustomFieldPreviousValuesPromise>() => T;
}

export interface ContactCustomFieldSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ContactCustomFieldSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ContactCustomFieldSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ContactCustomFieldPreviousValuesSubscription>() => T;
}

export interface ContactCustomFieldPreviousValues {
  id: Int;
  createdAt?: DateTimeOutput;
  fieldName: String;
  label: String;
  max?: String;
  min?: String;
  options?: Json;
  placeholder?: String;
  required: Boolean;
  tag: String;
  type?: String;
  updatedAt?: DateTimeOutput;
}

export interface ContactCustomFieldPreviousValuesPromise
  extends Promise<ContactCustomFieldPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  fieldName: () => Promise<String>;
  label: () => Promise<String>;
  max: () => Promise<String>;
  min: () => Promise<String>;
  options: () => Promise<Json>;
  placeholder: () => Promise<String>;
  required: () => Promise<Boolean>;
  tag: () => Promise<String>;
  type: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ContactCustomFieldPreviousValuesSubscription
  extends Promise<AsyncIterator<ContactCustomFieldPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  fieldName: () => Promise<AsyncIterator<String>>;
  label: () => Promise<AsyncIterator<String>>;
  max: () => Promise<AsyncIterator<String>>;
  min: () => Promise<AsyncIterator<String>>;
  options: () => Promise<AsyncIterator<Json>>;
  placeholder: () => Promise<AsyncIterator<String>>;
  required: () => Promise<AsyncIterator<Boolean>>;
  tag: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ContactCustomValueSubscriptionPayload {
  mutation: MutationType;
  node: ContactCustomValue;
  updatedFields: String[];
  previousValues: ContactCustomValuePreviousValues;
}

export interface ContactCustomValueSubscriptionPayloadPromise
  extends Promise<ContactCustomValueSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ContactCustomValuePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ContactCustomValuePreviousValuesPromise>() => T;
}

export interface ContactCustomValueSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ContactCustomValueSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ContactCustomValueSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ContactCustomValuePreviousValuesSubscription>() => T;
}

export interface ContactCustomValuePreviousValues {
  id: Int;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  value: String;
}

export interface ContactCustomValuePreviousValuesPromise
  extends Promise<ContactCustomValuePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  value: () => Promise<String>;
}

export interface ContactCustomValuePreviousValuesSubscription
  extends Promise<AsyncIterator<ContactCustomValuePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface JobSubscriptionPayload {
  mutation: MutationType;
  node: Job;
  updatedFields: String[];
  previousValues: JobPreviousValues;
}

export interface JobSubscriptionPayloadPromise
  extends Promise<JobSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = JobPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = JobPreviousValuesPromise>() => T;
}

export interface JobSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<JobSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = JobSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = JobPreviousValuesSubscription>() => T;
}

export interface JobPreviousValues {
  id: Int;
  attempts: Boolean;
  availableAt: Int;
  createdAt: Int;
  payload: String;
  queue: String;
  reservedAt?: Int;
}

export interface JobPreviousValuesPromise
  extends Promise<JobPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  attempts: () => Promise<Boolean>;
  availableAt: () => Promise<Int>;
  createdAt: () => Promise<Int>;
  payload: () => Promise<String>;
  queue: () => Promise<String>;
  reservedAt: () => Promise<Int>;
}

export interface JobPreviousValuesSubscription
  extends Promise<AsyncIterator<JobPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  attempts: () => Promise<AsyncIterator<Boolean>>;
  availableAt: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<Int>>;
  payload: () => Promise<AsyncIterator<String>>;
  queue: () => Promise<AsyncIterator<String>>;
  reservedAt: () => Promise<AsyncIterator<Int>>;
}

export interface MigrationSubscriptionPayload {
  mutation: MutationType;
  node: Migration;
  updatedFields: String[];
  previousValues: MigrationPreviousValues;
}

export interface MigrationSubscriptionPayloadPromise
  extends Promise<MigrationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MigrationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MigrationPreviousValuesPromise>() => T;
}

export interface MigrationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MigrationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MigrationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MigrationPreviousValuesSubscription>() => T;
}

export interface MigrationPreviousValues {
  id: Int;
  batch: Int;
  migration: String;
}

export interface MigrationPreviousValuesPromise
  extends Promise<MigrationPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  batch: () => Promise<Int>;
  migration: () => Promise<String>;
}

export interface MigrationPreviousValuesSubscription
  extends Promise<AsyncIterator<MigrationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  batch: () => Promise<AsyncIterator<Int>>;
  migration: () => Promise<AsyncIterator<String>>;
}

export interface OrgSubscriptionPayload {
  mutation: MutationType;
  node: Org;
  updatedFields: String[];
  previousValues: OrgPreviousValues;
}

export interface OrgSubscriptionPayloadPromise
  extends Promise<OrgSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrgPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrgPreviousValuesPromise>() => T;
}

export interface OrgSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrgSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrgSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrgPreviousValuesSubscription>() => T;
}

export interface OrgPreviousValues {
  id: Int;
  createdAt?: DateTimeOutput;
  name: String;
  phone: String;
  primaryEmail: String;
  updatedAt?: DateTimeOutput;
}

export interface OrgPreviousValuesPromise
  extends Promise<OrgPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  phone: () => Promise<String>;
  primaryEmail: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OrgPreviousValuesSubscription
  extends Promise<AsyncIterator<OrgPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  primaryEmail: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PasswordResetSubscriptionPayload {
  mutation: MutationType;
  node: PasswordReset;
  updatedFields: String[];
  previousValues: PasswordResetPreviousValues;
}

export interface PasswordResetSubscriptionPayloadPromise
  extends Promise<PasswordResetSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PasswordResetPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PasswordResetPreviousValuesPromise>() => T;
}

export interface PasswordResetSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PasswordResetSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PasswordResetSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PasswordResetPreviousValuesSubscription>() => T;
}

export interface PasswordResetPreviousValues {
  createdAt?: DateTimeOutput;
  email: String;
  token: String;
}

export interface PasswordResetPreviousValuesPromise
  extends Promise<PasswordResetPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  token: () => Promise<String>;
}

export interface PasswordResetPreviousValuesSubscription
  extends Promise<AsyncIterator<PasswordResetPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  token: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: Int;
  createdAt?: DateTimeOutput;
  email: String;
  emailVerifiedAt?: DateTimeOutput;
  orgId: Int;
  password: String;
  rememberToken?: String;
  role: UsersRoleEnum;
  updatedAt?: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  emailVerifiedAt: () => Promise<DateTimeOutput>;
  orgId: () => Promise<Int>;
  password: () => Promise<String>;
  rememberToken: () => Promise<String>;
  role: () => Promise<UsersRoleEnum>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  emailVerifiedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  orgId: () => Promise<AsyncIterator<Int>>;
  password: () => Promise<AsyncIterator<String>>;
  rememberToken: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<UsersRoleEnum>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Json = any;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Account",
    embedded: false
  },
  {
    name: "AccountCustomField",
    embedded: false
  },
  {
    name: "AccountCustomValue",
    embedded: false
  },
  {
    name: "Admin",
    embedded: false
  },
  {
    name: "Contact",
    embedded: false
  },
  {
    name: "ContactCustomField",
    embedded: false
  },
  {
    name: "ContactCustomValue",
    embedded: false
  },
  {
    name: "Job",
    embedded: false
  },
  {
    name: "Migration",
    embedded: false
  },
  {
    name: "Org",
    embedded: false
  },
  {
    name: "PasswordReset",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "UsersRoleEnum",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
